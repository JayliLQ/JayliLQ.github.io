{"title":"HTTP 协议","date":"2019-06-25T14:49:24.000Z","date_formatted":{"ll":"2019年6月25日","L":"2019/06/25","MM-DD":"06-25"},"link":"2019/06/25/14. HTTP 协议","tags":["网络协议"],"categories":["网络协议"],"updated":"2019-12-02T15:27:20.684Z","content":"<!-- build time:Sun Aug 23 2020 20:59:40 GMT+0800 (GMT+08:00) --><h2 id=\"HTTP-协议\">HTTP 协议<a href=\"2019/06/25/14. HTTP 协议#HTTP-协议\"></a></h2><ul><li>HTTP 协议是<strong>应用层</strong>最常用的协议</li><li><a href=\"http://www.163.com\" target=\"_blank\" rel=\"noopener\">http://www.163.com</a> 是个 URL，叫做统一资源定位符。http 是协议，<a href=\"http://www.163.com\" target=\"_blank\" rel=\"noopener\">www.163.com</a> 是域名，表示互联网上的一个位置，通过 DNS 服务器解析为具体的 IP 地址</li></ul><h2 id=\"HTTP-请求过程\">HTTP 请求过程<a href=\"2019/06/25/14. HTTP 协议#HTTP-请求过程\"></a></h2><h3 id=\"HTTP-请求准备\">HTTP 请求准备<a href=\"2019/06/25/14. HTTP 协议#HTTP-请求准备\"></a></h3><ol><li><p>将域名发送给 DNS 服务器，解析为具体的 IP 地址</p></li><li><p>建立 TCP 连接，三次握手</p><p><strong>在 HTTP 1.1 的协议里面，默认是 keep-alive 。</strong>所以建立的 TCP 连接，可以在多次请求中复用。</p></li></ol><h3 id=\"HTTP-请求构建\">HTTP 请求构建<a href=\"2019/06/25/14. HTTP 协议#HTTP-请求构建\"></a></h3><ul><li><p>HTTP 请求格式</p><p><img src=\"https://static001.geekbang.org/resource/image/10/74/10ff27d1032bf32393195f23ef2f9874.jpg\" alt=\"img\" class=\"article-img\"></p></li><li><p>请求行</p><p>方法：GET [获取信息]，POST [向服务器传输信息，新建]，PUT [向服务器上传更新信息，更新]，DELETE [删除资源]</p><p>URL：统一资源定位符，不是 IP</p><p>版本：HTTP 协议版本</p></li><li><p>首部</p><p>以 key-value 的形式设置信息，彼此通过冒号分隔。例如：</p><p>Accept-Charset，表示客户端可以接受的字符集</p><p>Content-Type，表示正文格式</p><p>Cache-control，控制缓存</p></li></ul><h3 id=\"HTTP-请求发送\">HTTP 请求发送<a href=\"2019/06/25/14. HTTP 协议#HTTP-请求发送\"></a></h3><ol><li>TCP 层在发送报文的时候，在 IP 头添加源 IP 地址和目标 IP 地址，交给 IP 层传输</li><li>IP 层判断目标地址是否和自己在同一局域网，若是，则发送 ARP 协议请求该目标 IP 地址的 MAC 地址，若不是，则发送 ARP 协议请求网关的 MAC 地址。</li><li>将源 MAC 地址和目标 MAC 地址放到 MAC 头，发送出去</li><li>网关接收到包，确定目标 MAC 地址和自己一致后，根据目标 IP 地址，找到下一跳路由器的 MAC 地址并设置为目标 MAC 地址，将包发送给下一跳路由器</li><li>不断执行上一步直到到达目标 IP 地址的局域网网关，网关发送 ARP ，获取到目标地址的 MAC 地址，将包发送出去</li><li>目标服务器解析 TCP 头的端口号，通过端口号将包发给相应的进程处理</li></ol><h3 id=\"HTTP-返回\">HTTP 返回<a href=\"2019/06/25/14. HTTP 协议#HTTP-返回\"></a></h3><ul><li><p>HTTP 返回报文格式</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/c1/1c2cfd4326d0dfca652ac8501321fac1.jpg\" alt=\"img\" class=\"article-img\"></p></li><li><p>返回过程和请求过程类似</p></li></ul><h2 id=\"HTTP-2-0\">HTTP 2.0<a href=\"2019/06/25/14. HTTP 协议#HTTP-2-0\"></a></h2><ul><li><p>HTTP 2.0 对 HTTP 的头进行一定的压缩，将原来每次需要携带的大量 key-value 在服务器和客户端建立一个索引表，对相同的头，只发送索引表中的索引</p></li><li><p>HTTP 2.0 将一个 TCP 连接请求，切分成多个流，每个流有自己的 ID</p></li><li><p>HTTP 2.0 将传输信息分割为更小的消息和帧。常见的帧有 Header 帧和 Data 帧，每个 Header 帧会开启一个新的流，同一个流里面有多个 Data 帧</p></li><li><p>每个帧可以乱序发送，通过帧首部的流标识符组装</p></li><li><p>HTTP 2.0 解决了 HTTP 1.1 的首部阻塞问题，减少了 TCP 连接数对服务器性能的影响</p><p><img src=\"https://static001.geekbang.org/resource/image/03/dd/03d4a216c024a9e761ed43c6787bf7dd.jpg\" alt=\"img\" class=\"article-img\"></p></li></ul><h2 id=\"QUIC-协议\">QUIC 协议<a href=\"2019/06/25/14. HTTP 协议#QUIC-协议\"></a></h2><p>HTTP 2.0 还是基于 TCP 协议的，在处理包的时候有严格的顺序，依旧会存在帧阻塞的问题</p><p>QUIC 协议基于 UDP 协议</p><ul><li><p>机制一：自定义连接</p><p>以一个 64 位随机数作为 ID 标识连接</p></li><li><p>机制二：自定义重传</p><p>发送的数据流设置偏移量 offset</p><p><img src=\"https://static001.geekbang.org/resource/image/da/c4/da2af1e419db66929dc85107c7250fc4.jpg\" alt=\"img\" class=\"article-img\"></p></li><li><p>机制三：无阻塞的多路复用</p><p>在自定义连接和重传机制的基础上，解决了多路复用</p></li><li><p>机制四：自定义流量控制</p><p>当前收到的最大 offset 到当前的 stream 所能容纳的最大缓存，是窗口大小</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/22/a66563b46906e7708cc69a02d43afb22.jpg\" alt=\"img\" class=\"article-img\"></p></li></ul><h2 id=\"小结\">小结<a href=\"2019/06/25/14. HTTP 协议#小结\"></a></h2><ul><li>HTTP 协议是基于 TCP 实现的</li><li>HTTP 协议头部标识的重要方法：GET, POST, PUT, DELETE</li><li>HTTP 2.0 通过头压缩，分帧，二进制编码，多路复用等技术提升性能</li><li>QUIC 协议是 Google 创造的，通过基于 UDP 自定义类似 TCP 的连接，重传，多路复用，流量控制技术，进一步提升性能</li></ul><h2 id=\"思考\">思考<a href=\"2019/06/25/14. HTTP 协议#思考\"></a></h2><ul><li>QUIC 是一个精巧的协议，所以它肯定不止今天提到的四种机制，你知道它还有哪些吗？</li><li>这一节主要讲了如何基于 HTTP 浏览网页，如果要传输比较敏感的银行卡信息，该怎么办呢？</li></ul><!-- rebuild by neat -->","prev":{"title":"HTTPS 协议","link":"2019/06/25/15. HTTPS 协议"},"next":{"title":"云中网络隔离","link":"2019/06/25/28. 云中网络的隔离GRE、VXLAN"},"plink":"https://www.jayli.cn/2019/06/25/14. HTTP 协议/","toc":[{"title":"HTTP 协议","id":"HTTP-协议","index":"1"},{"title":"HTTP 请求过程","id":"HTTP-请求过程","index":"2","children":[{"title":"HTTP 请求准备","id":"HTTP-请求准备","index":"2.1"},{"title":"HTTP 请求构建","id":"HTTP-请求构建","index":"2.2"},{"title":"HTTP 请求发送","id":"HTTP-请求发送","index":"2.3"},{"title":"HTTP 返回","id":"HTTP-返回","index":"2.4"}]},{"title":"HTTP 2.0","id":"HTTP-2-0","index":"3"},{"title":"QUIC 协议","id":"QUIC-协议","index":"4"},{"title":"小结","id":"小结","index":"5"},{"title":"思考","id":"思考","index":"6"}],"copyright":{"link":"<a href=\"https://www.jayli.cn/2019/06/25/14. HTTP 协议/\" title=\"HTTP 协议\">https://www.jayli.cn/2019/06/25/14. HTTP 协议/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2019年6月25日","author":"Jayli"}}