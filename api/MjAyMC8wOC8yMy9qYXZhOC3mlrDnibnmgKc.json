{"title":"java8 新特性","date":"2020-08-23T12:53:47.000Z","date_formatted":{"ll":"2020年8月23日","L":"2020/08/23","MM-DD":"08-23"},"link":"2020/08/23/java8-新特性","tags":["Java"],"categories":["Java"],"updated":"2020-08-23T13:11:27.505Z","content":"<!-- build time:Sun Aug 23 2020 21:12:13 GMT+0800 (GMT+08:00) --><p>函数式接口，Lambda 表达式，Stream 操作，Optional 类，全球化功能，IDEA 调试流式操作等等。</p><a id=\"more\"></a><h2 id=\"函数式接口\">函数式接口<a href=\"2020/08/23/java8-新特性#函数式接口\"></a></h2><p>通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。</p><p>在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure><h2 id=\"Lambda-表达式\">Lambda 表达式<a href=\"2020/08/23/java8-新特性#Lambda-表达式\"></a></h2><p>Lambda 表达式的初衷是进一步简化匿名内部类的语法，使 Java 走向函数式编程。</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"thread 1\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt; System.out.println(<span class=\"string\">\"thread 2\"</span>)).start();</span><br></pre></td></tr></table></div></figure><p>编译时：</p><ul><li>Lambda 表达式会生成一个方法，方法实现了表达式的代码逻辑</li><li>生成 invokedynamic 指令，调用 bootstrap 方法，由 java.lang.invoke.LambdaMetafactory.metafactory 方法实现</li></ul><p>运行时：</p><ul><li>invokedynamic 指令调用 metafactory 方法。它会返回一个 CallSite, 此 CallSite 返回目标类型的一个匿名实现类，此类关联编译时产生的方法</li><li>lambda 表达式调用时会调用匿名实现类关联的方法。</li></ul><p>Lambda 表达式由三个部分组成：第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块。语法如下：</p><ol><li><p>方法体为表达式，该表达式的值作为返回值返回。</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; expression</span><br></pre></td></tr></table></div></figure></li><li><p>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></div></figure></li></ol><p>要使用 Lambda 表达式，需要定义一个函数式接口，这样往往会让程序充斥着过量的仅为 Lambda 表达式服务的函数式接口。为了减少这样过量的函数式接口，Java 8 在 java.util.function 中增加了不少新的函数式通用接口。例如：</p><p>Function&lt;T, R&gt;：将 T 作为输入，返回 R 作为输出，他还包含了和其他函数组合的默认方法。</p><p>Predicate<t>：将 T 作为输入，返回一个布尔值作为输出，该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（与、或、非）。</t></p><p>Consumer<t>：将 T 作为输入，不返回任何内容，表示在单个参数上的操作。</t></p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Predicate接口是输入一个参数，返回布尔值。我们通过and方法组合两个Predicate条件，判断是否值大于0并且是偶数</span></span><br><span class=\"line\">Predicate&lt;Integer&gt; positiveNumber = i -&gt; i &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">Predicate&lt;Integer&gt; evenNumber = i -&gt; i % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">assertTrue(positiveNumber.and(evenNumber).test(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Consumer接口是消费一个数据。我们通过andThen方法组合调用两个Consumer，输出两行abcdefg</span></span><br><span class=\"line\">Consumer&lt;String&gt; println = System.out::println;</span><br><span class=\"line\">println.andThen(println).accept(<span class=\"string\">\"abcdefg\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Function接口是输入一个数据，计算后输出一个数据。我们先把字符串转换为大写，然后通过andThen组合另一个Function实现字符串拼接</span></span><br><span class=\"line\">Function&lt;String, String&gt; upperCase = String::toUpperCase;</span><br><span class=\"line\">Function&lt;String, String&gt; duplicate = s -&gt; s.concat(s);</span><br><span class=\"line\">assertThat(upperCase.andThen(duplicate).apply(<span class=\"string\">\"test\"</span>), is(<span class=\"string\">\"TESTTEST\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Supplier是提供一个数据的接口。这里我们实现获取一个随机数</span></span><br><span class=\"line\">Supplier&lt;Integer&gt; random = ()-&gt;ThreadLocalRandom.current().nextInt();</span><br><span class=\"line\">System.out.println(random.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//BinaryOperator是输入两个同类型参数，输出一个同类型参数的接口。这里我们通过方法引用获得一个整数加法操作，通过Lambda表达式定义一个减法操作，然后依次调用</span></span><br><span class=\"line\">BinaryOperator&lt;Integer&gt; add = Integer::sum;</span><br><span class=\"line\">BinaryOperator&lt;Integer&gt; subtraction = (a, b) -&gt; a - b;</span><br><span class=\"line\">assertThat(subtraction.apply(add.apply(<span class=\"number\">1</span>, <span class=\"number\">2</span>), <span class=\"number\">3</span>), is(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></div></figure><p>Lambda 表达式给了我们复用代码的更多可能性，我们可以把变化的部分抽象出函数式接口，由外部方法提供函数实现，重用方法用 default 在接口中实现。</p><h2 id=\"Stream\">Stream<a href=\"2020/08/23/java8-新特性#Stream\"></a></h2><p>创建流一般有五种方式：</p><ul><li>通过 stream 方法把 List 或数组转换为流；</li><li>通过 Stream.of 方法直接传入多个元素构成一个流；</li><li>通过 Stream.iterate 方法使用迭代的方式构造一个无限流，然后使用 limit 限制流元素个数；</li><li>通过 Stream.generate 方法从外部传入一个提供元素的 Supplier 来构造无限流，然后使用 limit 限制流元素个数；</li><li>通过 IntStream 或 DoubleStream 构造基本类型的流。</li></ul><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过stream方法把List或数组转换为流</span></span><br><span class=\"line\">Arrays.asList(<span class=\"string\">\"a1\"</span>, <span class=\"string\">\"a2\"</span>, <span class=\"string\">\"a3\"</span>).stream().forEach(System.out::println); </span><br><span class=\"line\">Arrays.stream(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//通过Stream.of方法直接传入多个元素构成一个流</span></span><br><span class=\"line\">String[] arr = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;; </span><br><span class=\"line\">Stream.of(arr).forEach(System.out::println); </span><br><span class=\"line\">Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>).forEach(System.out::println); </span><br><span class=\"line\">Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">\"a\"</span>).map(item -&gt; item.getClass().getName()).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//通过Stream.iterate方法使用迭代的方式构造一个无限流，然后使用limit限制流元素个数</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">2</span>, item -&gt; item * <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println); Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//通过Stream.generate方法从外部传入一个提供元素的Supplier来构造无限流，然后使用limit限制流元素个数</span></span><br><span class=\"line\">Stream.generate(() -&gt; <span class=\"string\">\"test\"</span>).limit(<span class=\"number\">3</span>).forEach(System.out::println); Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//通过IntStream或DoubleStream构造基本类型的流</span></span><br><span class=\"line\"><span class=\"comment\">//演示IntStream和DoubleStream </span></span><br><span class=\"line\">IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println); </span><br><span class=\"line\">IntStream.range(<span class=\"number\">0</span>, <span class=\"number\">3</span>).mapToObj(i -&gt; <span class=\"string\">\"x\"</span>).forEach(System.out::println); IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println); </span><br><span class=\"line\">DoubleStream.of(<span class=\"number\">1.1</span>, <span class=\"number\">2.2</span>, <span class=\"number\">3.3</span>).forEach(System.out::println); </span><br><span class=\"line\"><span class=\"comment\">//各种转换，后面注释代表了输出结果 </span></span><br><span class=\"line\">System.out.println(IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>).toArray().getClass()); <span class=\"comment\">//class [I </span></span><br><span class=\"line\">System.out.println(Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>).mapToInt(Integer::intValue).toArray().getClass()); <span class=\"comment\">//class [I </span></span><br><span class=\"line\">System.out.println(IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>).boxed().toArray().getClass()); <span class=\"comment\">//class [Ljava.lang.Object; </span></span><br><span class=\"line\">System.out.println(IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>).asDoubleStream().toArray().getClass()); <span class=\"comment\">//class [D </span></span><br><span class=\"line\">System.out.println(IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>).asLongStream().toArray().getClass()); <span class=\"comment\">//class [J </span></span><br><span class=\"line\"><span class=\"comment\">//注意基本类型流和装箱后的流的区别 </span></span><br><span class=\"line\">Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>).stream() <span class=\"comment\">// Stream </span></span><br><span class=\"line\">.mapToInt(String::length) <span class=\"comment\">// IntStream </span></span><br><span class=\"line\">.asLongStream() <span class=\"comment\">// LongStream </span></span><br><span class=\"line\">.mapToDouble(x -&gt; x / <span class=\"number\">10.0</span>) <span class=\"comment\">// DoubleStream </span></span><br><span class=\"line\">.boxed() <span class=\"comment\">// Stream </span></span><br><span class=\"line\">.mapToLong(x -&gt; <span class=\"number\">1L</span>) <span class=\"comment\">// LongStream </span></span><br><span class=\"line\">.mapToObj(x -&gt; <span class=\"string\">\"\"</span>) <span class=\"comment\">// Stream </span></span><br><span class=\"line\">.collect(Collectors.toList());</span><br></pre></td></tr></table></div></figure><h3 id=\"集合流式操作\">集合流式操作<a href=\"2020/08/23/java8-新特性#集合流式操作\"></a></h3><p>把集合的投影、转换、过滤等操作抽象成通用的接口，然后通过 Lambda 表达式传入其具体实现，就是 Stream 操作。</p><p>通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p><p>流有串行和并行两种，串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p><p>中间操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。终止操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。</p><h3 id=\"Stream-操作汇总\">Stream 操作汇总<a href=\"2020/08/23/java8-新特性#Stream-操作汇总\"></a></h3><p><img src=\"https://static001.geekbang.org/resource/image/44/04/44a6f4cb8b413ef62c40a272cb474104.jpg\" alt=\"\" class=\"article-img\"></p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//订单类</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long customerId;<span class=\"comment\">//顾客ID</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String customerName;<span class=\"comment\">//顾客姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;OrderItem&gt; orderItemList;<span class=\"comment\">//订单商品明细</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Double totalPrice;<span class=\"comment\">//总价格</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LocalDateTime placedAt;<span class=\"comment\">//下单时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//订单商品类</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long productId;<span class=\"comment\">//商品ID</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String productName;<span class=\"comment\">//商品名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Double productPrice;<span class=\"comment\">//商品价格</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer productQuantity;<span class=\"comment\">//商品数量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//顾客类</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;<span class=\"comment\">//顾客姓名</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最近半年的金额大于40的订单</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .filter(Objects::nonNull) <span class=\"comment\">//过滤null值</span></span><br><span class=\"line\">    .filter(order -&gt; order.getPlacedAt().isAfter(LocalDateTime.now().minusMonths(<span class=\"number\">6</span>))) <span class=\"comment\">//最近半年的订单</span></span><br><span class=\"line\">    .filter(order -&gt; order.getTotalPrice() &gt; <span class=\"number\">40</span>) <span class=\"comment\">//金额大于40的订单</span></span><br><span class=\"line\">    .forEach(System.out::println);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算所有订单商品数量</span></span><br><span class=\"line\"><span class=\"comment\">//1. 通过两次遍历实现</span></span><br><span class=\"line\">LongAdder longAdder = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">orders.stream().forEach(order -&gt;</span><br><span class=\"line\">        order.getOrderItemList().forEach(orderItem -&gt; longAdder.add(orderItem.getProductQuantity())));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 使用两次mapToLong+sum方法实现</span></span><br><span class=\"line\">assertThat(longAdder.longValue(), is(orders.stream().mapToLong(order -&gt;</span><br><span class=\"line\">        order.getOrderItemList().stream()</span><br><span class=\"line\">                .mapToLong(OrderItem::getProductQuantity).sum()).sum()));</span><br><span class=\"line\"><span class=\"comment\">//统计所有订单的总价格</span></span><br><span class=\"line\"><span class=\"comment\">//1. 直接展开订单商品进行价格统计</span></span><br><span class=\"line\">orders.stream() </span><br><span class=\"line\">    .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class=\"line\">    .mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()).sum();</span><br><span class=\"line\"><span class=\"comment\">//2. 另一种方式flatMap+mapToDouble=flatMapToDouble</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .flatMapToDouble(order -&gt; </span><br><span class=\"line\">                     order.getOrderItemList()</span><br><span class=\"line\">                     .stream().mapToDouble(item -&gt; </span><br><span class=\"line\">                     item.getProductQuantity() * item.getProductPrice()))</span><br><span class=\"line\">    .sum();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//大于50的订单,按照订单价格倒序前5</span></span><br><span class=\"line\">orders.stream().filter(order -&gt; order.getTotalPrice() &gt; <span class=\"number\">50</span>)</span><br><span class=\"line\">    .sorted(comparing(Order::getTotalPrice).reversed())</span><br><span class=\"line\">    .limit(<span class=\"number\">5</span>)</span><br><span class=\"line\">    .forEach(System.out::println);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//去重的下单用户</span></span><br><span class=\"line\">orders.stream().map(order -&gt; order.getCustomerName()).distinct().collect(joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"><span class=\"comment\">//所有购买过的商品</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class=\"line\">    .map(OrderItem::getProductName)</span><br><span class=\"line\">    .distinct().collect(joining(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照下单时间排序，查询前2个订单的顾客姓名和下单时间</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .sorted(comparing(Order::getPlacedAt))</span><br><span class=\"line\">    .map(order -&gt; order.getCustomerName() + <span class=\"string\">\"@\"</span> + order.getPlacedAt())</span><br><span class=\"line\">    .limit(<span class=\"number\">2</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//按照下单时间排序，查询第3和第4个订单的顾客姓名和下单时间</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .sorted(comparing(Order::getPlacedAt))</span><br><span class=\"line\">    .map(order -&gt; order.getCustomerName() + <span class=\"string\">\"@\"</span> + order.getPlacedAt())</span><br><span class=\"line\">    .skip(<span class=\"number\">2</span>).limit(<span class=\"number\">2</span>).forEach(System.out::println);</span><br></pre></td></tr></table></div></figure><h3 id=\"Collectors-类常用静态方法\">Collectors 类常用静态方法<a href=\"2020/08/23/java8-新特性#Collectors-类常用静态方法\"></a></h3><p><img src=\"https://static001.geekbang.org/resource/image/5a/de/5af5ba60d7af2c8780b69bc6c71cf3de.png\" alt=\"\" class=\"article-img\"></p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//按照用户名分组，统计下单数量</span></span><br><span class=\"line\">System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, counting()))</span><br><span class=\"line\">        .entrySet().stream().sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照用户名分组，统计订单总金额</span></span><br><span class=\"line\">System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, summingDouble(Order::getTotalPrice)))</span><br><span class=\"line\">        .entrySet().stream().sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照用户名分组，统计商品采购数量</span></span><br><span class=\"line\">System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName,</span><br><span class=\"line\">        summingInt(order -&gt; order.getOrderItemList().stream()</span><br><span class=\"line\">                .collect(summingInt(OrderItem::getProductQuantity)))))</span><br><span class=\"line\">        .entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//统计最受欢迎的商品，倒序后取第一个</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">        .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class=\"line\">        .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))</span><br><span class=\"line\">        .entrySet().stream()</span><br><span class=\"line\">        .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed())</span><br><span class=\"line\">        .map(Map.Entry::getKey)</span><br><span class=\"line\">        .findFirst()</span><br><span class=\"line\">        .ifPresent(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//统计最受欢迎的商品的另一种方式，直接利用maxBy</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">        .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class=\"line\">        .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))</span><br><span class=\"line\">        .entrySet().stream()</span><br><span class=\"line\">        .collect(maxBy(Map.Entry.comparingByValue()))</span><br><span class=\"line\">        .map(Map.Entry::getKey)</span><br><span class=\"line\">        .ifPresent(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照用户名分组，选用户下的总金额最大的订单</span></span><br><span class=\"line\">orders.stream().collect(groupingBy(Order::getCustomerName, collectingAndThen(maxBy(comparingDouble(Order::getTotalPrice)), Optional::get)))</span><br><span class=\"line\">        .forEach((k, v) -&gt; System.out.println(k + <span class=\"string\">\"#\"</span> + v.getTotalPrice() + <span class=\"string\">\"@\"</span> + v.getPlacedAt()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据下单年月分组，统计订单ID列表</span></span><br><span class=\"line\">System.out.println(orders.stream().collect</span><br><span class=\"line\">        (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(<span class=\"string\">\"yyyyMM\"</span>)),</span><br><span class=\"line\">                mapping(order -&gt; order.getId(), toList()))));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据下单年月+用户名两次分组，统计订单ID列表</span></span><br><span class=\"line\">System.out.println(orders.stream().collect</span><br><span class=\"line\">        (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(<span class=\"string\">\"yyyyMM\"</span>)),</span><br><span class=\"line\">                groupingBy(order -&gt; order.getCustomerName(),</span><br><span class=\"line\">                        mapping(order -&gt; order.getId(), toList())))));</span><br></pre></td></tr></table></div></figure><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生成一定位数的随机字符串</span></span><br><span class=\"line\">System.out.println(random.ints(<span class=\"number\">48</span>, <span class=\"number\">122</span>)</span><br><span class=\"line\">    .filter(i -&gt; (i &lt; <span class=\"number\">57</span> || i &gt; <span class=\"number\">65</span>) &amp;&amp; (i &lt; <span class=\"number\">90</span> || i &gt; <span class=\"number\">97</span>))</span><br><span class=\"line\">    .mapToObj(i -&gt; (<span class=\"keyword\">char</span>) i)</span><br><span class=\"line\">    .limit(<span class=\"number\">20</span>)</span><br><span class=\"line\">    .collect(StringBuilder::<span class=\"keyword\">new</span>, StringBuilder::append, StringBuilder::append)</span><br><span class=\"line\">    .toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//所有下单的用户，使用toSet去重后实现字符串拼接</span></span><br><span class=\"line\">System.out.println(orders.stream()</span><br><span class=\"line\">    .map(order -&gt; order.getCustomerName()).collect(toSet())</span><br><span class=\"line\">    .stream().collect(joining(<span class=\"string\">\",\"</span>, <span class=\"string\">\"[\"</span>, <span class=\"string\">\"]\"</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用toCollection收集器指定集合类型</span></span><br><span class=\"line\">System.out.println(orders.stream().limit(<span class=\"number\">2</span>).collect(toCollection(LinkedList::<span class=\"keyword\">new</span>)).getClass());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用toMap获取订单ID+下单用户名的Map</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .collect(toMap(Order::getId, Order::getCustomerName))</span><br><span class=\"line\">    .entrySet().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用toMap获取下单用户名+最近一次下单时间的Map</span></span><br><span class=\"line\">orders.stream()</span><br><span class=\"line\">    .collect(toMap(Order::getCustomerName, Order::getPlacedAt, (x, y) -&gt; x.isAfter(y) ? x : y))</span><br><span class=\"line\">    .entrySet().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//订单平均购买的商品数量</span></span><br><span class=\"line\">System.out.println(orders.stream().collect(averagingInt(order -&gt;</span><br><span class=\"line\">    order.getOrderItemList().stream()</span><br><span class=\"line\">            .collect(summingInt(OrderItem::getProductQuantity)))));</span><br></pre></td></tr></table></div></figure><h3 id=\"partitionBy\">partitionBy<a href=\"2020/08/23/java8-新特性#partitionBy\"></a></h3><p>partitioningBy 用于分区，分区是特殊的分组，只有 true 和 false 两组。比如，我们把用户按照是否下单进行分区，给 partitioningBy 方法传入一个 Predicate 作为数据分区的区分，输出是 Map</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据是否有下单记录进行分区</span></span><br><span class=\"line\">System.out.println(Customer.getData().stream().collect(</span><br><span class=\"line\">        partitioningBy(customer -&gt; orders.stream().mapToLong(Order::getCustomerId)</span><br><span class=\"line\">                .anyMatch(id -&gt; id == customer.getId()))));</span><br></pre></td></tr></table></div></figure><h3 id=\"其他\">其他<a href=\"2020/08/23/java8-新特性#其他\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 要通过 HashMap 实现一个缓存的操作,先判断缓存中是否有值；如果没有值，就从数据库搜索取值；最后，把数据加入缓存.</span></span><br><span class=\"line\">Map cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 当Key不存在的时候提供一个Function来代表根据Key获取Value的过程</span></span><br><span class=\"line\">cache.computeIfAbsent(id, i -&gt; Product.getData().stream() </span><br><span class=\"line\">                      .filter(p -&gt; p.getId().equals(i)) <span class=\"comment\">//过滤 </span></span><br><span class=\"line\">                      .findFirst() <span class=\"comment\">//找第一个，得到Optional </span></span><br><span class=\"line\">                      .orElse(<span class=\"keyword\">null</span>)); <span class=\"comment\">//如果找不到Product，则使用null</span></span><br><span class=\"line\"></span><br><span class=\"line\">List &lt;TjfxDimensionDTO&gt; dqrAjList;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 根据 corp 字段分组，并计算分组后的 zs 字段的总和</span></span><br><span class=\"line\">dqrAjList.stream().collect(Collectors.groupingBy(TjfxDimensionDTO::getCorp, Collectors.summingInt(TjfxDimensionDTO::getZs)));</span><br><span class=\"line\"><span class=\"comment\">// 根据 id 正排序</span></span><br><span class=\"line\">dqrAjList.stream().sorted(Comparator.comparing(TjfxDimensionDTO::getId)).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// 过滤 dqrAjList 中， code 不等于 \"xx\" 的元素</span></span><br><span class=\"line\">dqrAjList.stream().filter(x -&gt; x.getCode().equals(<span class=\"string\">\"xx\"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></div></figure><h2 id=\"Optional-类\">Optional 类<a href=\"2020/08/23/java8-新特性#Optional-类\"></a></h2><p>Optional 类是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型 T 的值，或者仅仅保存 null。Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常。</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 若 countMap.get(corpId) 为空，返回 0</span></span><br><span class=\"line\">Optional.ofNullable(countMap.get(corpId)).orElse(<span class=\"number\">0L</span>);</span><br><span class=\"line\"><span class=\"comment\">//通过get方法获取Optional中的实际值</span></span><br><span class=\"line\">assertThat(Optional.of(<span class=\"number\">1</span>).get(), is(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">//通过ofNullable来初始化一个null，通过orElse方法实现Optional中无数据的时候返回一个默认值</span></span><br><span class=\"line\">assertThat(Optional.ofNullable(<span class=\"keyword\">null</span>).orElse(<span class=\"string\">\"A\"</span>), is(<span class=\"string\">\"A\"</span>));</span><br><span class=\"line\"><span class=\"comment\">//OptionalDouble是基本类型double的Optional对象，isPresent判断有无数据</span></span><br><span class=\"line\">assertFalse(OptionalDouble.empty().isPresent());</span><br><span class=\"line\"><span class=\"comment\">//通过map方法可以对Optional对象进行级联转换，不会出现空指针，转换后还是一个Optional</span></span><br><span class=\"line\">assertThat(Optional.of(<span class=\"number\">1</span>).map(Math::incrementExact).get(), is(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">//通过filter实现Optional中数据的过滤，得到一个Optional，然后级联使用orElse提供默认值</span></span><br><span class=\"line\">assertThat(Optional.of(<span class=\"number\">1</span>).filter(integer -&gt; integer % <span class=\"number\">2</span> == <span class=\"number\">0</span>).orElse(<span class=\"keyword\">null</span>), is(nullValue()));</span><br><span class=\"line\"><span class=\"comment\">//通过orElseThrow实现无数据时抛出异常</span></span><br><span class=\"line\">Optional.empty().orElseThrow(IllegalArgumentException::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></div></figure><h2 id=\"全球化功能\">全球化功能<a href=\"2020/08/23/java8-新特性#全球化功能\"></a></h2><p>LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Duration，DateTimeFormatter</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LocalDate</span></span><br><span class=\"line\">LocalDate localDate = LocalDate.now(); <span class=\"comment\">//获取本地日期</span></span><br><span class=\"line\">localDate = LocalDate.ofYearDay(<span class=\"number\">2020</span>, <span class=\"number\">200</span>); <span class=\"comment\">// 获得 2020 年的第 200 天 </span></span><br><span class=\"line\">System.out.println(localDate.toString());<span class=\"comment\">//输出：2020-08-20</span></span><br><span class=\"line\">localDate = LocalDate.of(<span class=\"number\">2020</span>, Month.SEPTEMBER, <span class=\"number\">10</span>); <span class=\"comment\">//2020 年 9 月 10 日 </span></span><br><span class=\"line\">System.out.println(localDate.toString());<span class=\"comment\">//输出：2020-09-10</span></span><br><span class=\"line\">LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE); <span class=\"comment\">// 20200820</span></span><br><span class=\"line\"><span class=\"comment\">//LocalTime</span></span><br><span class=\"line\">LocalTime localTime = LocalTime.now(); <span class=\"comment\">//获取当前时间</span></span><br><span class=\"line\">System.out.println(localTime.toString());<span class=\"comment\">//输出当前时间</span></span><br><span class=\"line\">localTime = LocalTime.of(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">50</span>);<span class=\"comment\">//获得 10:20:50 的时间点</span></span><br><span class=\"line\">System.out.println(localTime.toString());<span class=\"comment\">//输出: 10:20:50</span></span><br><span class=\"line\"><span class=\"comment\">//Clock 时钟</span></span><br><span class=\"line\">Clock clock = Clock.systemDefaultZone();<span class=\"comment\">//获取系统默认时区 (当前瞬时时间 )</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> millis = clock.millis();<span class=\"comment\">//</span></span><br></pre></td></tr></table></div></figure><h2 id=\"IDEA-调试-Stream\">IDEA 调试 Stream<a href=\"2020/08/23/java8-新特性#IDEA-调试-Stream\"></a></h2><p><a href=\"https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html\" target=\"_blank\" rel=\"noopener\">https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html</a></p><h2 id=\"参考\">参考<a href=\"2020/08/23/java8-新特性#参考\"></a></h2><ul><li><a href=\"https://www.oracle.com/java/technologies/javase/8-whats-new.html\" target=\"_blank\" rel=\"noopener\">JDK 8 中的新特性</a></li><li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html\" target=\"_blank\" rel=\"noopener\">Java 8 新特性概述</a></li><li><a href=\"https://www.baeldung.com/java-optional\" target=\"_blank\" rel=\"noopener\">Guide To Java 8 Optional</a></li><li><a href=\"https://time.geekbang.org/column/article/212374\" target=\"_blank\" rel=\"noopener\">Java 8的那些重要知识点（一）</a></li><li><a href=\"https://time.geekbang.org/column/article/212398\" target=\"_blank\" rel=\"noopener\">Java 8的那些重要知识点（二）</a></li><li><a href=\"https://colobu.com/2014/11/06/secrets-of-java-8-lambda/\" target=\"_blank\" rel=\"noopener\">Java 8 Lambda 揭秘</a></li></ul><!-- rebuild by neat -->","next":{"title":"Json errors","link":"2019/12/01/errors"},"plink":"https://www.jayli.cn/2020/08/23/java8-新特性/","toc":[{"title":"函数式接口","id":"函数式接口","index":"1"},{"title":"Lambda 表达式","id":"Lambda-表达式","index":"2"},{"title":"Stream","id":"Stream","index":"3","children":[{"title":"集合流式操作","id":"集合流式操作","index":"3.1"},{"title":"Stream 操作汇总","id":"Stream-操作汇总","index":"3.2"},{"title":"Collectors 类常用静态方法","id":"Collectors-类常用静态方法","index":"3.3"},{"title":"partitionBy","id":"partitionBy","index":"3.4"},{"title":"其他","id":"其他","index":"3.5"}]},{"title":"Optional 类","id":"Optional-类","index":"4"},{"title":"全球化功能","id":"全球化功能","index":"5"},{"title":"IDEA 调试 Stream","id":"IDEA-调试-Stream","index":"6"},{"title":"参考","id":"参考","index":"7"}],"copyright":{"link":"<a href=\"https://www.jayli.cn/2020/08/23/java8-新特性/\" title=\"java8 新特性\">https://www.jayli.cn/2020/08/23/java8-新特性/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年8月23日","author":"Jayli"}}