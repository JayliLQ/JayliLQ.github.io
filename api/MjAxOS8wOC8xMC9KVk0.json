{"title":"JVM","date":"2019-08-10T13:35:57.000Z","date_formatted":{"ll":"2019年8月10日","L":"2019/08/10","MM-DD":"08-10"},"link":"2019/08/10/JVM","tags":["Java,JVM"],"categories":["Java"],"updated":"2019-12-02T14:21:58.354Z","content":"<!-- build time:Sun Aug 23 2020 20:59:41 GMT+0800 (GMT+08:00) --><p>主要内容：Java 官网，源码，类文件，类加载机制，类装载器，运行时数据区，内存结构模型，垃圾回收，JVM 参数，常用命令和工具</p><a id=\"more\"></a><h2 id=\"JVM-前奏篇\">JVM 前奏篇<a href=\"2019/08/10/JVM#JVM-前奏篇\"></a></h2><p>官网：<a href=\"http://www.oracle.com\" target=\"_blank\" rel=\"noopener\">www.oracle.com</a></p><p>Java官方会针对不同的操作系统提供不同的 JVM</p><p>JDK 包括 JRE，JRE 包括 JVM</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564143981024.png\" alt=\"1564143981024\" class=\"article-img\"></p><p>.java 编译后 –&gt; .class 类文件</p><p>javac person.java –&gt; person.class</p><p>java person</p><p>如何设计 javac 这款编译器？编译原理：</p><ol><li>词法分析器 —&gt; token 流</li><li>语法分析器 —&gt; 语法树/抽象语法树</li><li>语义分析器 —&gt; 注解语法树</li><li>代码生成器 —&gt; 字节码</li></ol><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">javap</span> <span class=\"selector-tag\">-c</span> <span class=\"selector-tag\">person</span><span class=\"selector-class\">.class</span> &gt; <span class=\"selector-tag\">person</span><span class=\"selector-class\">.txt</span></span><br></pre></td></tr></table></div></figure><p>subline 查看 .class 文件</p><p>cafe babe –&gt; 前 4 位标识 class 文件</p><blockquote><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> ClassFile &#123;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u4             magic;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             minor_version;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             major_version;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             constant_pool_count;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     cp_info        constant_pool[constant_pool_count-1];</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             access_flags;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             this_class;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             super_class;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             interfaces_count;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             interfaces[interfaces_count];</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             fields_count;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     field_info     fields[fields_count];</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             methods_count;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     method_info    methods[methods_count];</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     u2             attributes_count;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">     attribute_info attributes[attributes_count];</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"></span></span><br></pre></td></tr></table></div></figure></blockquote><p>不同的语言，只要能转成符合 JVM 规范的 .class 文件，JVM 就能运行</p><p>class 文件如何进入到 JVM 中运行？</p><p>类装载机制</p><ul><li>JVM 会把 class 文件加载到内存</li><li>对数据进行校验，转换，解析，初始化</li><li>面向对象开发语言 class 文件—&gt; java.lang.Class 对象代表</li></ul><ol><li>查找和导入 class 文件（用 ClassLoader 类去找）<ul><li>装载：通过一个类的全限定路径名，获取此类文件对应的二进制字节流—-》classLoader</li><li>链接：将这个字节流对应的静态存储结构 转化为 方法区运行时数据结构—-》方法区</li><li>初始化：Java 堆内存中 生产一个代表这个类的 java.lang.Class 对象—-》堆</li></ul></li><li>链接<ul><li>验证：保证被加载类的正确性。文件格式，元数据，字节码，符号引用</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转换为直接引用</li></ul></li><li>初始化<ul><li>对类的静态变量，静态代码块初始化</li></ul></li></ol><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564146378606.png\" alt=\"1564146378606\" class=\"article-img\"></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564146812081.png\" alt=\"1564146812081\" class=\"article-img\"></p><p>当需要加载一个 class 文件时，从 bootstrap classLoader 开始往下加载</p><p>若 bootstrap ClassLoader 加载到了，则子加载器不再加载；</p><p>若 Bootstrap ClassLoader 没有加载到，则 Extension ClassLoader 加载</p><p>…</p><p>破坏双亲委派：自定义类加载时，不从 parent 开始加载</p><p><strong>Heap</strong>: 被所有线程共享，存储对象（包含普通的变量，全局变量，成员变量）</p><p>对于方法而言，最重要的时被执行，如何才能被执行？</p><ul><li>主函数（主线程）中调用</li><li>方法要被执行，一定是被线程所调用的</li></ul><p>Java 进程：包含很多<strong>线程</strong>，线程用于执行方法</p><ul><li>程序计数器</li><li>Java 栈 （一个Java 虚拟机栈是与一个线程对应的，执行很多方法）</li><li>本地方法栈（native）</li></ul><p><strong>方法区</strong>：只有一个，被所有线程共享，堆的一部分，非堆</p><ul><li>运行时常量池</li></ul><p>类的信息，常量，静态变量</p><blockquote><p>作业：</p><p>01-简述JDK，JRE，JVM之间的关系(最好结合官网的原话)</p><p>JDK：Java development kit, Java 开发工具箱</p><p>JRE：Java runtime environment，Java 运行环境</p><p>JVM：Java virtual machine，Java 虚拟机</p><p>JDK 包含 JRE，JRE 包含 JVM</p><p>02-常用.class类文件的查看方式有哪些？</p><ol><li>用 javap 命令查看</li><li>用反编译工具输出 java 文件查看</li><li>用 subline 查看</li></ol><p>03-描述一下类加载机制的含义和过程</p><p>含义：JVM 将类加载到内存中，使程序能够运行</p><p>过程：</p><ol><li>查找类：根据全限定路径名，获取二进制字节流–&gt;将对应字节流的静态数据结构转化位动态的运行数据结构–&gt;在堆中生成实例对象</li><li>链接：验证–&gt;准备–&gt;解析</li><li>初始化：静态变量初始化</li></ol><p>04-说说你对Heap(堆)、Method Area(方法区)和Run-Time Constant Pool(运行时常量池)的理解(最好结合官网)</p><p>Heap：被所有线程共享，存储实例对象。在 JVM 启动时创建。大小可以固定的，也可以按需增大减小。在内存中不需要连续存储空间。需要的空间超过可分配空间时会导致内存溢出。</p><p>方法区：被所有线程共享，存储类结构（运行时常量池，属性，方法数据），方法代码，构造器等。在 JVM 气功时创建，逻辑上时堆的一部分。大小可以固定，也可以按需增大减小。在内存中不需要连续存储空间。需要的空间超过可分配空间时会导致内存溢出。</p><p>常量池：是每个类或接口在运行时的表示，包含多种类型的常量。由方法区在 JVM 创建类或接口时分配空间。需要的空间超过可分配空间时会导致内存溢出。</p></blockquote><h2 id=\"JVM-进行篇—JVM-内存模型\">JVM 进行篇—JVM 内存模型<a href=\"2019/08/10/JVM#JVM-进行篇—JVM-内存模型\"></a></h2><p><img src=\"https://i.loli.net/2019/07/06/5d201e5be46c913224.png\" alt=\"\" class=\"article-img\"></p><p>结合类加载机制看 运行时数据区</p><p>虚拟机栈，本地方法区，程序计数器 跟随线程的生命周期，是线程私有的，线程安全的</p><p>堆，方法区跟随 JVM 进程的生命周期，是线程共享的，非线程安全的</p><p><strong>方法区</strong>（Metaspace）：存储类相关描述信息，常量，静态变量，即时编译器编译后的代码等数据</p><p><strong>堆</strong>：实例对象，数组</p><p><strong>虚拟机栈</strong>：方法（栈帧）</p><p><strong>程序计数器</strong>：记录当前线程执行方法的位置</p><p><strong>本地方法栈</strong>：标记的 native 方法</p><p><img src=\"https://i.loli.net/2019/10/14/hvkfxb7GHKu5XMe.png\" alt=\"\" class=\"article-img\"><br><img src=\"https://i.loli.net/2019/10/14/a9JrEBOjzotSlDG.png\" alt=\"\" class=\"article-img\"></p><p>栈帧：操作数栈，局部变量表，动态链接，方法返回地址</p><p>操作数栈：</p><ul><li>ldc : 将常量从常量池中拿出来，压入操作数栈</li><li>putfield：给对象字段赋值</li><li>ldc2_w：将常量池中的常量（int,long,double）入操作数栈</li><li>iconst_3：将 3 入操作数栈</li><li>istore_0：将栈顶int类型的值保存到局部变量值 0 中</li><li>iload_0：从局部变量 0 中装载 int 类型值入栈操作数栈</li></ul><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564232294668.png\" alt=\"1564232294668\" class=\"article-img\"></p><p><a href=\"https://www.jianshu.com/p/0cd8322a116b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0cd8322a116b</a></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564234735757.png\" alt=\"1564234735757\" class=\"article-img\"></p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看<span class=\"keyword\">jav进程 </span>：<span class=\"keyword\">jps </span>-l </span><br><span class=\"line\"></span><br><span class=\"line\">可视化查看 <span class=\"keyword\">JVM </span>：<span class=\"keyword\">jvisualvm</span></span><br></pre></td></tr></table></div></figure><p>新创建的对象首先放 Eden 区，Eden 区放不下的大对象放 Old 区，Eden 区创建了很多对象，慢慢不够用了，有可能 Eden 区有没用的对象，触发垃圾回收（minor GC），释放一些空间出来。</p><p>垃圾回收范围：整个 young 区（Eden，S0，S1）</p><p>Eden 区垃圾回收后，一定确保 Eden 区是空的</p><ul><li>有些对象被回收掉</li><li>一些对象仍然存活</li></ul><p>再次垃圾回收后</p><ul><li>回收 Eden 区，Eden 区为空</li><li>某一个 S 区为空</li></ul><p>每次 GC ，对象的年龄都会 +1，对象年龄达到一定值后，移动到 Old 区</p><p>Old 区不够用了，触发 Major GC（一次 Major GC 会包括一次 Minor GC）</p><p>Major GC + Minor GC = Full GC</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564235736150.png\" alt=\"1564235736150\" class=\"article-img\"></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564235776899.png\" alt=\"1564235776899\" class=\"article-img\"></p><p>如果 young 区不拆分成 Eden + S0 + S1 ：</p><ul><li>GC 之后，内存空间不连续</li><li><p>Old 区对象越来越多，Major GC 频率增大，很耗性能</p></li><li><p>两个 S 区：解决碎片化，内存空间不连续。需要保证 GC 后 Eden 区 和一个 S 区为空</p></li></ul><p>Eden ：S0：S1 = 8 : 1 : 1</p><p>Minor GC 后从 Eden 区来的对象，S 区放不下，跟 Old 区借一些，分配担保机制</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564236764959.png\" alt=\"1564236764959\" class=\"article-img\"></p><p><strong>宁可多次 Minor GC，减少 Major GC</strong></p><blockquote><p>01-说说你对PC寄存器、Java虚拟机栈以及栈帧的理解</p><p>PC 寄存器：用于记录线程中当前执行方法的位置</p><p>Java 虚拟机栈：用于存放当前线程的调用方法，根据调用关系从 main 方法开始依次入栈，先进后出。</p><p>栈帧：线程中一个方法对应一个栈帧，用于存放操作数，局部变量，动态链接，方法返回地址</p><p>一个线程对应一个PC 寄存器，一个Java 虚拟机栈（包含多个栈帧）</p><p>02-类的装载方式有哪些？</p><ol><li>new 对象装载</li><li>ClassLoader 装载</li><li>Class.forName 装载</li></ol><p>03-再次概括一下类加载机制的全过程，以及每个过程详细的操作</p><ol><li><p>加载</p><p>根据全限定类名找到类对应的二进制字节流，遵从双亲委派原则，父加载器找到了类，则子加载器不再继续查找同类名的类。</p></li><li><p>链接</p><p>2.1 验证：对元数据，文件格式，符号引用，字节码进行验证，确保类的正确性</p><p>2.2 准备：为静态变量分配内存，并赋值为类型的默认值</p><p>2.3 解析：将类中的符号引用转化为能理解的直接引用</p></li><li><p>初始化</p><p>对静态变量，静态代码块初始化</p></li></ol><p>04-内存模型主要是针对运行时数据区哪两块区域的实现？内存模型结构是如何划分的？</p><ol><li>方法区和堆</li><li>方法区+堆（Eden+S0+S1+Old）。其中 Eden ：S0：S1 = 8 ：1：1，Eden + S0 + S1 为 young 区。</li></ol><p>05-结合一个对象的一辈子，简述你对堆内存中的Eden，S0，S1和Old区的理解</p><p>新产生的对象，首先进入 Eden 区，若对象过大，则将其放入 Old 区。当 Eden 区中的对象越来越多，会触发 Minor GC，一次 Minor GC 会将 Eden 中还存活的对象放入当前空白的 S0 区，将另一个非空的 S1 区中还存活的对象也移动到 S0 区，然后将现在空白的 S1 区变为 S0, 将非空的 S0 变为 S1。在 Minor GC 后存活的对象年龄都加 1，当对象年龄达到一定值后，将对象移动到 Old 区。当 Old 区的对象越来越多，达到一定阈值后触发 Major GC，清除掉 Old 区中没有存活的对象。一个 Major GC 会伴随着一次 Minor GC。young 区分为 Eden，S0，S1 是为了在 Minor GC 后释放出连续的存储空间，从而减少 Old 区对象的存放，降低 Major GC 的频率。</p></blockquote><h2 id=\"JVM-升华篇—垃圾收集器\">JVM 升华篇—垃圾收集器<a href=\"2019/08/10/JVM#JVM-升华篇—垃圾收集器\"></a></h2><p><strong>类的装载方式有哪些？</strong></p><ul><li>本地系统加载</li><li>网络下载 .class 文件</li><li>zip, jar， .class 文件</li><li>DB 提取</li><li>java 源码文件编译 class</li><li>Class.forName()</li><li>ClassLoader.loadClass() 加载</li></ul><p>应用—Java 进程—JVM 进程—JVM 实例—独立内存模型 ：一个堆，一个方法区，多个进程</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">jps </span>-l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">jinfo </span>-flag MaxHeapSize 进程id</span><br></pre></td></tr></table></div></figure><p><strong>对象的占用空间组成</strong>（指针压缩：UseCompress）</p><ul><li>对象头（由操作系统的位数组成：32/64）</li><li>实例数据（根据数据类型决定，对于引用类型的数据：32（4 byte）；64（6 byte））</li><li>对齐填充（由虚拟机位数决定）</li></ul><h3 id=\"垃圾回收\">垃圾回收<a href=\"2019/08/10/JVM#垃圾回收\"></a></h3><h4 id=\"判断一个对象是否是垃圾？\">判断一个对象是否是垃圾？<a href=\"2019/08/10/JVM#判断一个对象是否是垃圾？\"></a></h4><ul><li><p>引用计数法</p><ul><li>弊端：循环引用的问题，AB 相互持有引用，导致永远不能被回收</li></ul></li><li><p>可达性分析：某一个对象是否是垃圾，通过 Root 进行可达性分析</p><ul><li><p>有些对象永远不会被回收：Root 对象</p></li><li><p>可用作 Root 的对象：类加载器，Thread, 虚拟机栈中的本地变量表，static 成员，常量引用，本地方法栈中的变量等</p></li></ul></li></ul><h4 id=\"进行垃圾回收\">进行垃圾回收<a href=\"2019/08/10/JVM#进行垃圾回收\"></a></h4><p>Java 虽然是自动进行垃圾回收的 ，C/C++ 是手动进行垃圾回收的</p><p>System.gc() —&gt; 可以让 JVM 进行一次垃圾回收：发出一个垃圾回收的指令，但是什么时候进行垃圾回收还是 JVM 决定</p><p>垃圾回收策略/算法</p><ul><li>标记–清除：Mark–Sweep<ul><li>对内存空间做一个扫描，标记哪些对象是垃圾，再做一次扫描，清除垃圾</li><li>内存空间不连续，空间碎片，从而导致 GC 频率增加</li><li>标记和清除的空间扫描都比较消耗时间</li></ul></li><li>标记–复制<ul><li>内存空间分为大小相等的两部分，保持 50% 的空间的空白</li><li>空间利用率低，造成空间浪费</li><li>内存空间分为三部分 8：1：1</li><li>新生代：对象朝生夕死，一次 GC 后绝大部分都死了，复制成本少，GC 效率高，从而降低 GC 频率</li></ul></li><li>标记–整理<ul><li>能够减少 GC 频率，相对连续的空间能够使用了，完全利用空间</li></ul></li></ul><p>老年代对象存活时间较长，选择清除/整理算法</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564319883242.png\" alt=\"1564319883242\" class=\"article-img\"></p><p>Serial</p><p>串行，jdk 1.3 之前，新生代唯一的一个选择</p><p>只会用一个 CPU，单线程收集器，用一条垃圾线程去收集</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564320423109.png\" alt=\"1564320423109\" class=\"article-img\"></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564320535616.png\" alt=\"1564320535616\" class=\"article-img\"></p><p>Parallel Scavenge: ParNew 基础上，更加关注系统的吞吐量</p><p>吞吐量 === 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</p><p>ex: JVM 虚拟机总共运行了 100 分钟，垃圾收集用了 1 分钟，则吞吐量 = （100-1）/100</p><p>吞吐量越高，意味着：垃圾收集时间越短，用户代码执行时间越长，用户代码就充分使用到了 CPU 的资源，尽快地完成运算任务</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564320936969.png\" alt=\"1564320936969\" class=\"article-img\"></p><p>GC 可以开启一个线程，也可以开启多个线程</p><p>CMS：concurrent mark sweep <strong>标记–清除</strong></p><ul><li>初始标记 ：<ul><li>CMS initial mark，标记 GC Roots 能够关联到地对象，找出有多少个垃圾，存活对象。stop the world —&gt; 其他应用程序线程都暂停，很快</li><li>单线程</li></ul></li><li>并发标记：<ul><li>进行 GC Root Tracing</li><li>垃圾回收线程和用户线程能够同时进行，交替执行</li></ul></li><li>重新标记<ul><li>修改并发标记因用户程序变动的内容，stop the world</li><li>多线程</li></ul></li><li>并发清除<ul><li>垃圾回收线程和用户线程能够同时进行，交替执行</li></ul></li></ul><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564321601290.png\" alt=\"1564321601290\" class=\"article-img\"></p><ul><li>优点：<ul><li>并发收集—停顿时间少，低停顿—吞吐量 JVM 重点</li></ul></li><li>缺点<ul><li>产生大量空间碎片，并发阶段会降低吞吐量</li></ul></li></ul><p>G1 ：<strong>标记—整理</strong></p><p>约定：保留老年代，新生代的概念。堆内存的布局—独立区域，大小相等的 region。新生代和老年代不再有物理上的隔离</p><ul><li>不会产生空间碎片</li><li>指定可预测的停顿时间</li><li>初始标记<ul><li>标记 GC Roots , TAMS 记录存活对象，暂停用户线程</li></ul></li><li>并发标记<ul><li>从 GC Roots 可达性分析</li></ul></li><li>最终标记<ul><li>根据用户期望的停顿时间，筛选回收</li></ul></li><li>筛选回收</li></ul><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564322490877.png\" alt=\"1564322490877\" class=\"article-img\"></p><p>总结：</p><p>垃圾收集器分类</p><ul><li>串行收集器：单个线程，并暂停用户线程，只能有一个垃圾回收线程。适用于内存比较小的嵌入式设备</li><li>并行收集器（Parallel Scanvenge, parallel Old）：更加关注吞吐量多个垃圾回收线程并行工作，但是用户线程还是暂停等待状态。适用于科学计算，后台处理等若交互场景。</li><li>并发收集器（CMS，G1）：更加关注停顿时间。用户线程和垃圾收集线程交替执行（同时执行），垃圾收集线程时不会暂停用户线程的执行。适用于相对时间有要求的场景，比如 Web 场景</li></ul><p>吞吐量和停顿时间：评价垃圾回收器好处的标准，调优的时候也是不断观察这两个参数的变化</p><p>吞吐量 ：运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</p><p>停顿时间：垃圾收集器进行垃圾回收，终端应用执行响应的时间</p><p>jdk 不同的版本</p><p>G1 : jdk 1.7 开始使用, jdk 1.8 非常成熟 ，jdk 默认垃圾收集器，适用于新老生带</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">jps </span>-l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">jinfo </span>-flag UseG1GC 进程id</span><br></pre></td></tr></table></div></figure><p>如何选择垃圾收集器？</p><ul><li>优先调整堆的内存大小，让服务器自己选择</li><li>如果内存大小 &lt; 100M ,使用串行收集器</li><li>如果是单核，并且没有停顿时间要求，使用串行或 JVM 自己选</li><li>如果允许停顿时间超过 1s，选择并行或则 JVM 自己选</li><li>如果响应时间比较重要，并且不能超过 1s 停顿时间，使用并发收集器</li></ul><blockquote><p>作业</p><p>01-怎样确定一个对象为垃圾？</p><p>1）引用计数，没有被引用的对象为垃圾。有弊端：对相互引用的对象无法判断为垃圾</p><p>2）通过 Roots 对象进行可达性分析：有些对象永远不会被回收，例如 类加载器，Thread, 虚拟机栈中的局部变量表，静态成员变量，常量引用，本地方法栈中的变量等</p><p>02-常用的垃圾回收算法有哪些？</p><p>1）标记–清除：先全区扫描，标记垃圾对象，再一次全区扫描，清除垃圾对象。适用于 old 区。缺点是存在空间碎片，造成存储空间不连续，进而造成 GC 频率增大。</p><p>2）标记–复制：保留一块空白的连续内存区，先扫描非空白区域，标记垃圾对象，再将存活的对象全部复制到空白的区域，连续存放。适用于young 区。解决了存储空间不连续的问题，缺点是总有一块空白区域存在，到 GC 的时候才会被使用，导致空间利用率低。</p><p>3）标记–整理：先全区扫描，标记垃圾对象，再一次全区扫描，将移动存活对象，将其连续存放。适用于 old 区。解决了存储空间不连续的问题，缺点是全区扫描，消耗时间较长。</p><p>03-说说常用的垃圾收集器，以及它们适用的区域和特点</p><p>Serial GC，Serial Old：jdk 1.3 以前用的是 Serial GC，单线程，GC 进程运行时会暂停用户进程。适用于内存比较小的嵌入式设备</p><p>Parallel Scanvenge, parallel Old：在 ParaNew 基础上更多关注吞吐量。多线程 GC，GC 进程运行时会暂停用户进程。适用于科学计算，后台应用等弱交互的场景。</p><p>CMS，G1：更多关注停顿时间。并行 GC，GC 进程运行时不会暂停用户进程时间很短，可以与用户进程并发标记和并发清理。适用于对停顿时间有要求的场景，例如 Web 场景。</p><p>04-简述你对吞吐量和停顿时间的理解</p><p>吞吐量 = 用户代码运行时间/(用户代码运行时间 + GC 时间)</p><p>停顿时间：GC 回收时，终端应用执行的响应时间</p><p>吞吐量和停顿时间用于评价 GC 性能的好坏，JVM 调优时也是观察这两个参数的变化</p></blockquote><h2 id=\"JVM-实战篇\">JVM 实战篇<a href=\"2019/08/10/JVM#JVM-实战篇\"></a></h2><p>JVM 参数和工具</p><h3 id=\"JVM-参数\">JVM 参数<a href=\"2019/08/10/JVM#JVM-参数\"></a></h3><ul><li>标准参数：不同的 jdk 版本，是一样的<ul><li>-version， -help</li></ul></li><li>-X 参数：java -Xint -version<ul><li>-Xint</li><li>-Xcomp</li><li>-Xmixed</li></ul></li><li>-XX 参数<ul><li>Boolean 类型：-XX:+UseG1GC -XX:+UseConcMarkSweepGC</li><li>非 Boolean 类型: -XX:<name>=<value>-XX:InitialHeapSize=100M</value></name></li></ul></li><li>其他类型:简写<ul><li>Xms100M -XX:InitialHeapSize=100M</li><li>Xmx100M -XX:MaxHeapSize=100M</li><li>Xss100k -XX:ThreadStackSize=100k ===&gt; 虚拟机栈帧大小</li></ul></li></ul><p>查看当前 java 进程中，参数有多少个？</p><p>java -XX:+PrintFlagsFinal -version</p><p>:= 表示参数进行过修改</p><h3 id=\"常用命令\">常用命令<a href=\"2019/08/10/JVM#常用命令\"></a></h3><p><a href=\"https://docs.oracle.com/apps/search/search.jsp?q=jinfo&amp;category=java\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/apps/search/search.jsp?q=jinfo&amp;category=java</a></p><p>jdk/bin: javac java javadoc javap</p><p>单位：byte</p><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>Byte (字节) = <span class=\"number\">8</span>bit (位)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>KB = <span class=\"number\">1024</span>Byte(字节)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>MB = <span class=\"number\">1024</span>KB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>GB = <span class=\"number\">1024</span>MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>TB = <span class=\"number\">1024</span>GB</span><br></pre></td></tr></table></div></figure><ul><li>jps: 查看系统中有的 java 进程数 —&gt;PID<ul><li>jps -l</li></ul></li><li>jinfo: 查看实时 JVM 参数,某一个 Java 进程 JVM 参数的值。实时设置 JVM 参数<ul><li>jinfo -flag JVM参数 进程ID</li><li>jinfo -flags 进程ID</li></ul></li><li>jstat: 查看 JVM 虚拟机性能统计信息<ul><li>jstat -class 18044 1000 10</li><li>jstat -gc 18044 1000 10</li></ul></li><li>jstack: 查看当前线程堆栈信息<ul><li>jstack 18044</li></ul></li><li>jmap：堆内存信息<ul><li>jmap -heap PID</li><li>当生产环境发生 OOM，能够自动导出 heap 文件，便于分析哪里出现了问题（用 Eclipse MAT 查看）</li><li>jmap -dump:format=b,file=heap.hprof PID &lt;==&gt; -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</li></ul></li></ul><h3 id=\"代替命令操作的工具\">代替命令操作的工具<a href=\"2019/08/10/JVM#代替命令操作的工具\"></a></h3><p>jdk/bin</p><ul><li>jconsole</li><li>jvisualvm</li></ul><p>查看远程服务器的信息</p><p>ps -ef|grep tomcat</p><p>JMX – 生产服务器中监听一个端口</p><p>配置远程服务器 catalina.sh</p><p>开启防火墙，配置安全组，允许以下端口访问</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564405449721.png\" alt=\"1564405449721\" class=\"article-img\"></p><p>方法区 metaspace 信息，生成类相关信息</p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564405956574.png\" alt=\"1564405956574\" class=\"article-img\"></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564406938166.png\" alt=\"1564406938166\" class=\"article-img\"></p><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564406108968.png\" alt=\"1564406108968\" class=\"article-img\"></p><p>stackOverFlowError: 栈帧溢出, 默认 7956</p><p>JVM 参数设置虚拟机栈容量：-Xss128k</p><p>优先让 JVM 默认值（合理值：3000-5000）</p><p>太小：栈会经常溢出</p><p>太大：机器硬件性能能够容量的线程数量是有限的</p><p>jstack pid ：查看到死锁原因</p><p>非堆里面也会有垃圾，也会进行垃圾收集，但是我们更多关注的是堆的垃圾收集</p><p>GC 什么时候进行？</p><p>JVM 自动完成的，根据 JVM 系统环境而定的，时机是不确定的</p><ul><li>System.gc() 发出一个信号，什么时候 GC 还是等待 JVM 执行</li><li>Eden 区或 S 区不够用了</li><li>Old 区不够用了</li><li>方法区 MetaSpace 不够用了</li></ul><p><img src=\"C:\\Users\\Jayli\\AppData\\Roaming\\Typora\\typora-user-images\\1564407997072.png\" alt=\"1564407997072\" class=\"article-img\"></p><h2 id=\"JVM-终结篇\">JVM 终结篇<a href=\"2019/08/10/JVM#JVM-终结篇\"></a></h2><p>gcviewer 工具 : <a href=\"https://gceasy.io\" target=\"_blank\" rel=\"noopener\">https://gceasy.io</a></p><blockquote><p>01-JVM常用的参数类型有哪些？</p><p>1) 标准参数，如 -version, -help</p><p>2) -X 参数，如 -Xint, -Xmixed, -Xcomp</p><p>3) -XX Boolean 类型, 如 -XX:UseG1GC; -XX 非 Boolean 类型，如 -XX:InitialHeapSize=100M</p><p>4) 其他类型，简写，如 Xms100M 等价于 -XX:InitialHeapSize=100M</p><p>02-JVM中常用的命令和工具有哪些，并说出它们的作用？</p><p>1）命令：</p><p>​ jps: 查看系统中所有 Java 进程</p><p>​ jinfo: 查看实时的 JVM 参数，实时设置 JVM 参数</p><p>​ jstat: 查看 JVM 性能统计信息</p><p>​ jstack: 查看当前线程堆栈信息</p><p>​ jmap: 查看堆信息，可设置堆内存溢出时导出 dump 文件</p><p>2）工具: jdk/bin 中的工具 jconsole，jvisualvm 。不用命令行即可在图形化界面查看 JVM 信息，Java 进程信息等，也可远程连接，查看远程服务的 JVM 信息。</p><p>03-如果让你代码演示一下堆，方法区的内存溢出，你会怎么做和配置？</p><p>堆内存溢出：先设置较小的堆内存（ 如 Xmx50M），启动应用后不断产生对象而不销毁，使 Old 区中对象一直累积最终溢出</p><p>方法区内存溢出：先设置较小的方法区内存（如 -XX:MaxPermSize=30M），启动应用后不断产生常量，静态变量等，使方法区一直累积最终溢出</p><p>04-虚拟机栈中方法递归调用了会怎么样？线程死锁可以用什么命令查看？</p><p>虚拟机栈中方法递归调用次数过多，超出虚拟机栈深度，会导致虚拟机栈溢出 StackOverFlowError。线程死锁可用命令 jstack PID 查看</p><p>05-演示一下tomcat启动时gc日志的打印结果，最好能截图放到作业中，配置参数我提供给大家<br>XX:+Print<strong><em>etails -XX:+PrintGCTimeStamps -XX:+Print</em></strong>ateStamps<br>-Xloggc:$CATALINA_HOME/logs/gc.log</p><blockquote><p>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:$CATALINA_HOME/logs/gc.log</p></blockquote></blockquote><!-- rebuild by neat -->","prev":{"title":"URL编码","link":"2019/08/15/URL编码"},"next":{"title":"Spring Boot 笔记","link":"2019/08/02/Spring Boot 笔记"},"plink":"https://www.jayli.cn/2019/08/10/JVM/","toc":[{"title":"JVM 前奏篇","id":"JVM-前奏篇","index":"1"},{"title":"JVM 进行篇—JVM 内存模型","id":"JVM-进行篇—JVM-内存模型","index":"2"},{"title":"JVM 升华篇—垃圾收集器","id":"JVM-升华篇—垃圾收集器","index":"3","children":[{"title":"垃圾回收","id":"垃圾回收","index":"3.1","children":[{"title":"判断一个对象是否是垃圾？","id":"判断一个对象是否是垃圾？","index":"3.1.1"},{"title":"进行垃圾回收","id":"进行垃圾回收","index":"3.1.2"}]}]},{"title":"JVM 实战篇","id":"JVM-实战篇","index":"4","children":[{"title":"JVM 参数","id":"JVM-参数","index":"4.1"},{"title":"常用命令","id":"常用命令","index":"4.2"},{"title":"代替命令操作的工具","id":"代替命令操作的工具","index":"4.3"}]},{"title":"JVM 终结篇","id":"JVM-终结篇","index":"5"}],"copyright":{"link":"<a href=\"https://www.jayli.cn/2019/08/10/JVM/\" title=\"JVM\">https://www.jayli.cn/2019/08/10/JVM/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2019年8月10日","author":"Jayli"}}