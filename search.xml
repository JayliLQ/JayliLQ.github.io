<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Json errors]]></title>
    <url>%2F2019%2F12%2F01%2Ferrors%2F</url>
    <content type="text"><![CDATA[JSONObject.fromObject() 无法读取到属性值。JSON运用 JSONObject.fromObject() 将对象转换为 JSON ，log 如下1- Property 'name' of class LocalTest$JsonTest2 has no read method. SKIPPEDJSONObject 会将所有 setXXX 的方法，获取对应的 getXXX 方法调用 getXXX 方法获得 XXX 属性的值对一个 Bean 类来讲，可以没有属性，但是只要有 public getter 方法 Java 的内省机制就会认为存在一个属性，比如类中有方法 getMobile ，那么就认为存在一个 mobile 的属性。1234567891011121314public class JsonTest2 &#123; public String getName() &#123; return "sss"; &#125;&#125;@Testpublic void jsonTest() &#123; JsonTest2 jsonTest = new JsonTest2(); System.out.println(JSONObject.fromObject(jsonTest));&#125;输出：&#123;"name":"sss"&#125;解决：所有 setXXX 方法需要有 getXXX]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 原理]]></title>
    <url>%2F2019%2F11%2F26%2FTomcat%2F</url>
    <content type="text"><![CDATA[Tomcat 是 Web 容器，Servlet 容器。是 J2EE 规范，在 Java 环境下支持 Web 开发Java 的 Socket 网络编程12345678910111213141516171819ServerSocket server = new ServerSocket(8080);while(true) &#123; Socket client = server.accept(); InputStream in = client.getInputStream(); byte[] buff = new byte[1024]; int len = 0; String content = ""; if ((len = is.read(buff)) &gt; 0) &#123; content = new String(buff, 0, len); &#125; OutputStream out = client.getOutputStream(); StringBuffer sb = new StringBuffer(); sb.append("HTTP/1.1 "+ 200 + "OK\n"); sb.append("Content-Type: text/html;\n"); sb.append("\r\n"); sb.append("Hello, Tomcat!"); out.write(sb.toString().getBytes()); out.close();&#125;浏览器请求必须的参数Request：浏览器发送的请求包含所有信息的封装Response：服务器要向浏览器响应信息的封装Servlet：处理得到请求以后的 Java 执行逻辑，service()Tomcat url 和 Servlet 的关联关系被保存起来了，Servlet 容器保存了所有的 Servlet 对象Tomcat 处理请求步骤Web App 的 web.xml 文件加载进来，完成 url 和 Servlet 的映射关系启动 ServletSocket 监听 8080获取客户端 Socket 对象，解析 HTTP 请求的协议内容，封装成 Request 对象。拼装 HTTP 响应的协议内容，封装成 Response 对象通过 URL 找到对应的 Servlet，用反射调用 Servlet 的 service() 方法，执行自定义逻辑。doGet()/doPost()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyExcel插入指定大小图片]]></title>
    <url>%2F2019%2F11%2F25%2FEasyExcel%E6%8F%92%E5%85%A5%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[用 EasyExcel 填充模板时，插入的图片会被压缩到一个单元格的大小。指定图片大小的解决方法如下：将内容填充进模板12345678ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateFileName).registerWriteHandler(new imageEnhance()).build();WriteSheet writeSheet = EasyExcel.writerSheet().build();FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();byte[] signature = FileUtils.readFileToByteArray(ResourceUtils.getFile("classpath:testImg.png"));map.put("signature", signature);excelWriter.fill(map, fillConfig, writeSheet);excelWriter.finish();注入灵魂…class imageEnhance implements CellWriteHandler { @Override public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Head head, Integer integer, Integer integer1, Boolean aBoolean) {} @Override public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell, Head head, Integer integer, Boolean aBoolean) {} @Override public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData&gt; list, Cell cell, Head head, Integer integer, Boolean aBoolean) { int curRowIndex = cell.getRowIndex(); int curColIndex = cell.getColumnIndex(); CellData cellData = list.get(0); if (CellDataTypeEnum.IMAGE.equals(cellData.getType())) { Workbook wb = writeSheetHolder.getParentWriteWorkbookHolder().getWorkbook(); Drawing&lt;?&gt; patriarch = writeSheetHolder.getSheet().createDrawingPatriarch(); ClientAnchor anchor = new XSSFClientAnchor(0, 0, 0, 0, (short) curColIndex, curRowIndex, (short) curColIndex + 3, curRowIndex + 6); anchor.setAnchorType(ClientAnchor.AnchorType.DONT_MOVE_AND_RESIZE); byte[] imgByte = list.get(0).getImageValue(); patriarch.createPicture(anchor, wb.addPicture(imgByte, HSSFWorkbook.PICTURE_TYPE_PNG)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS 服务器配置]]></title>
    <url>%2F2019%2F11%2F20%2FHTTPS-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[HTTPS 在 Nginx 上的配置。123456789101112131415server &#123;listen 443; #指定ssl监听端口server_name www.example.com;ssl on; #开启ssl支持ssl_certificate /etc/nginx/server.pem; #指定服务器证书路径ssl_certificate_key /etc/nginx/server.key; #指定私钥证书路径ssl_session_timeout 5m;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #指定SSL服务器端支持的协议版本ssl_ciphers ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP; #指定加密算法ssl_prefer_server_ciphers on; #在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法#以下内容请按域名需要进行配置，此处仅供参考location / &#123;return 444;&#125;&#125;Openssl提供了简单的client和server工具，可以用来模拟SSL连接，做测试使用。1234567891011121314151617# 连接到远程服务器&gt; openssl s_client -connect www.google.com.hk:443# 模拟的HTTPS服务，可以返回Openssl相关信息 # -accept 用来指定监听的端口号 # -cert -key 用来指定提供服务的key和证书&gt; openssl s_server -accept 443 -cert myserver.crt -key myserver.key -www# 可以将key和证书写到同一个文件中&gt; cat myserver.crt myserver.key &gt; myserver.pem# 使用的时候只提供一个参数就可以了&gt; openssl s_server -accept 443 -cert myserver.pem -www# 可以将服务器的证书保存下来&gt; openssl s_client -connect www.google.com.hk:443 &lt;/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; remoteserver.pem# 转换成DER文件，就可以在Windows下直接查看了&gt; openssl x509 -outform der -in remoteserver.pem -out remoteserver.cer测试 ssl 连接：openssl s_client -connect b2bit.huaqin.com:10443参考：微信开发文档 HTTPS 服务器配置openssl 证书操作命令]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议,Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统 IO 模型]]></title>
    <url>%2F2019%2F11%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO-%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[TCP 连接传输数据时的过程httpd进程处理文件类请求时比较完整的数据操作流程]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与反序列化]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java 对象必须 implements Serializable 才能序列化序列化1new ObjectOutputStream(new FileOutputStream("packingListInfoPO")).writeObject(packingListInfo);反序列化1TbLgFactoryPackingListInfoPO packingListInfo = (TbLgFactoryPackingListInfoPO) new ObjectInputStream(new FileInputStream("packingListInfoPO")).readObject();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Unit-Test]]></title>
    <url>%2F2019%2F11%2F03%2FSpring-Unit-Test%2F</url>
    <content type="text"><![CDATA[pom 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;测试类加注解 @RunWith(SpringRunner.class),@SpringBootTest测试方法加注解 @Test]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务]]></title>
    <url>%2F2019%2F11%2F02%2FSpring-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Spring 事务不生效方法内部调用事务不生效抛出一个RuntimeException才能回滚调用的方法必须是public，否则事务不起作用123456789101112* REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 * REPEATABLE_READ：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读) * readOnly：不允许只读 rollbackFor:回滚策略为Exception出现异常之后 * TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 函数内捕获异常时需要来设置事务回滚状态 * Spring Transactional一直是RD的事务神器，但是如果用不好，反会伤了自己。下面总结@Transactional经常遇到的几个场景: @Transactional 加于private方法, 无效 @Transactional 加于未加入接口的public方法, 再通过普通接口方法调用, 无效 @Transactional 加于接口方法, 无论下面调用的是private或public方法, 都有效 @Transactional 加于接口方法后, 被本类普通接口方法直接调用, 无效 @Transactional 加于接口方法后, 被本类普通接口方法通过接口调用, 有效 @Transactional 加于接口方法后, 被它类的接口方法调用, 有效 @Transactional 加于接口方法后, 被它类的私有方法调用后, 有效Java Error and Exception12345678910111213141516 | Throwable | +-----------+ / \ / \+-------+ +-----------+| Error | | Exception |+-------+ +-----------+ / | \ / | \ \\________/ \______/ \ +------------------+unchecked checked | RuntimeException | +------------------+ / | | \ \_________________/ unchecked]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 理解]]></title>
    <url>%2F2019%2F11%2F01%2FTomcat-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[tomcat是jdk+servlet(严格地说是+jsp)实现的精简版的java ee，由于它只在jdk的基础上附加了jsp和servlet类库，所以它的应用范围主要是web应用。123456789101112131415161718192021222324组织结构：&lt;server&gt; &lt;service&gt; &lt;connector /&gt; &lt;connector /&gt; &lt;container&gt; &lt;engine&gt; &lt;host&gt; &lt;context /&gt; &lt;context /&gt; &lt;/host&gt; &lt;host&gt; &lt;context&gt; &lt;wrapper /&gt; &lt;/context&gt; &lt;/host&gt; &lt;/engine&gt; &lt;container&gt; &lt;/service&gt; &lt;service&gt; ...... &lt;/service&gt;&lt;/server&gt;tomcat 安装目录结构1234567bin: 脚本文件conf: 配置文件lib: 类库logs: 默认日志目录temp: 临时目录webapps: 存放web程序的根目录work: 存放编译后生成的class文件，JSP页面生成的Servlet放在work路径对应的Web应用下问题tomcat startup 启动闪退查看本地有没有其他 tomcat 线程已经启动，占用的默认端口 8005，若有，则修改 %CATALINA_HOME%\conf\server.xml 中的 Server port查看是否设置 JAVA_HOME，CATALINA_HOME，CATALINA_BASE 环境变量。若没有，则有以下两种解决方法：设置系统环境变量或者在 %CATALINA_HOME%\bin\startup.bat，%CATALINA_HOME%\bin\shutdown.bat 文件开始位置指定这几个变量的值123set JAVA_HOME=E:\java\jdk1.7.0_07set CATALINA_HOME=E:\test\apache-tomcat-7.0.59set CATALINA_BASE=E:\test\apache-tomcat-7.0.59%CATALINA_HOME%\RUNNING.txt 中建议将环境变量配置到 setenv.bat 中，在 %CATALINA_HOME%\bin 目录下新建文件 setenv.bat，文件内容为1234set "JAVA_HOME=E:\java\jdk1.7.0_07"set "CATALINA_HOME=E:\test\apache-tomcat-7.0.59"set "CATALINA_BASE=E:\test\apache-tomcat-7.0.59"exit /b 0注意：运用命令启动 [%CATALINA_HOME%\bin\catalina.bat start] /停止 [%CATALINA_HOME%\bin\catalina.bat stop] tomcat, 使用 startup.bat/shutdown.bat 会报错:Cannot find “”This file is needed to run this program.其原因是 catalina.bat 中会执行 setenv.bat 而 startup.bat 中没有执行 setenv.batTomcat Server处理一个http请求的过程假设来自客户的请求为：http://localhost:8080/wsota/wsota_index.jsp1) 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得2) Connector把该请求交给它所在的Service的Engine来处理 ，并等待来自Engine的回应3) Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host4) Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）5) localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context6) Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为””的Context去处理）7) path=”/wsota”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet8) Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类9) 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法10)Context把执行完了之后的HttpServletResponse对象返回给Host11)Host把HttpServletResponse对象返回给Engine12)Engine把HttpServletResponse对象返回给Connector13)Connector把HttpServletResponse对象返回给客户browser参考：Tomcat(一)：背景知识和安装tomcatTomcat(二)：tomcat配置文件server.xml详解和部署简介Tomcat(三)：tomcat处理连接的详细过程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2F2019%2F10%2F25%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密算法学习对称加密算法用同一个密钥加密和解密，速度快，适合给大量数据加密DES3DES：DES 的衍生AES （支持三种长度的密钥）AES256：安全性最高AES192AES128：性能最高非对称加密算法公钥加密，私钥解密；私钥签名，公钥验签。和对称加密相比，安全性高，速度较慢RSADSAECC散列算法（签名算法）加密不可逆，能确定消息的不可抵赖性，能保障消息的完整性。主要用于身份验证：文件校验，数字签名，授权协议。MD5SHA1：160 位的哈希值SHA2：SHA1 的衍生，有多种不同的位数SHA512SHA384SHA256SHA224HMAC其他常用算法Base64HTTPSSSL 证书（HTTPS）背后的加密算法参考 SSL证书(HTTPS)背后的加密算法浏览器把自身支持的一系列Cipher Suite（密钥算法套件，后文简称Cipher）[C1,C2,C3, …]发给服务器；服务器接收到浏览器的所有Cipher后，与自己支持的套件作对比，如果找到双方都支持的Cipher，则告知浏览器；浏览器与服务器使用匹配的Cipher进行后续通信。如果服务器没有找到匹配的算法，浏览器（以Firefox 30为例，后续例子中使用的浏览器均为此版本的Firefox）将给出错误信息密钥算法套件（Cipher Suite）查看浏览器支持的 Cipher：打开Firefox浏览器，在地址栏中输入about:config，然后搜索tls.version查看服务器支持的 Cipher：以Windows为例。若要查看操作系统支持哪些密钥算法，可以运行gpedit.msc，依次进入”Computer Configuration” -&gt; ”Administrative Templates” -&gt; “Network” -&gt; “SSL Configuration Settings”Cipher 名称含义：密钥交换算法，用于决定客户端与服务器之间在握手的过程中如何认证，用到的算法包括RSA，Diffie-Hellman，ECDH，PSK等加密算法，用于加密消息流，该名称后通常会带有两个数字，分别表示密钥的长度和初始向量的长度，比如DES 56/56, RC2 56/128, RC4 128/128, AES 128/128, AES 256/256报文认证信息码（MAC）算法，用于创建报文摘要，确保消息的完整性（没有被篡改），算法包括MD5，SHA等。PRF（伪随机数函数），用于生成“master secret”。例如：TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA基于TLS协议的；使用ECDHE、RSA作为密钥交换算法；加密算法是AES（密钥和初始向量的长度都是256）；MAC算法（这里就是哈希算法）是SHA。参考密码技术]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议,加密,TLS/SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F10%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式总结.^ 匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”$ 匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa匹配前面元字符1次或多次，/ba/将匹配ba,baa,baaa? 匹配前面元字符0次或1次，/ba/将匹配b,ba(x) 匹配x保存x在名为$1…$9的变量中x|y 匹配x或y{n} 精确匹配n次{n,} 匹配n次以上{n,m} 匹配n-m次[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^xyz] 不匹配这个集合中的任何一个字符[\b] 匹配一个退格符\b 匹配一个单词的边界\B 匹配一个单词的非边界\cX 这儿，X是一个控制符，/\cM/匹配Ctrl-M\d 匹配一个字数字符，/\d/ = /[0-9]/\D 匹配一个非字数字符，/\D/ = /[^0-9]/\n 匹配一个换行符\r 匹配一个回车符\s 匹配一个空白字符，包括\n,\r,\f,\t,\v等\S 匹配一个非空白字符，等于/[^\n\f\r\t\v]/\t 匹配一个制表符\v 匹配一个重直制表符\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\w]匹配”$5.98”中的5，等于[a-zA-Z0-9]\W 匹配一个不可以组成单词的字符，如[\W]匹配”$5.98”中的$，等于[^a-zA-Z0-9]直接量字母数字字符 自身\ f 换页符\ n 换行符\ r 回车\ t 制表符\ v 垂直制表符\ / 一个 / 直接量\ \ 一个 \ 直接量\ . 一个 . 直接量\ 一个 直接量\ + 一个 + 直接量\ ? 一个 ? 直接量\ | 一个 | 直接量\ ( 一个 ( 直接量\ ) 一个 ) 直接量\ [ 一个 [ 直接量\ ] 一个 ] 直接量\ { 一个 { 直接量\ } 一个 } 直接量\ XXX 由十进制数 XXX 指 定的ASCII码字符\ Xnn 由十六进制数 nn 指定的ASCII码字符\ cX 控制字符^X. 例如, \cI等价于 \t, \cJ等价于 \n如果想在正则表达式中使用特殊的标点符号,必须在它们之前加上一个 “\” .字符类[…] 位于括号之内的任意字符[^…] 不在括号之中的任意字符. 除了换行符之外的任意字符,等价于[^\n]\w 任何单字字符, 等价于[a-zA-Z0-9]\W 任何非单字字符,等价于[^a-zA-Z0-9]\s 任何空白符,等价于[\ t \ n \ r \ f \ v]\S 任何非空白符,等价于[^\ t \ n \ r \ f \ v]\d 任何数字,等价于[0-9]\D 除了数字之外的任何字符,等价于[^0-9][\b] 一个退格直接量(特例)复制/\d{2, 4}/ //匹配2到4间的数字./\w{3} \d?/ //匹配三个单字字符和一个任意的数字./\s+java\s+/ //匹配字符串”java” ,并且该串前后可以有一个或多个空格./[^”] * / //匹配零个或多个非引号字符.{n, m} 匹配前一项至少n次,但是不能超过m次{n, } 匹配前一项n次,或者多次{n} 匹配前一项恰好n次? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}匹配前一项1次或多次,等价于{1,}匹配前一项0次或多次.等价于{0,}选择，分组和引用| 选择.匹配的要么是该符号左边的子表达式,要么它右边的子表达式(…) 分组.将几个项目分为一个单元.这个单元可由 *、+、？和|等符号使用,而且还可以记住和这个组匹配的字符以供此后引\n 和第n个分组所匹配的字符相匹配.分组是括号中的子表达式(可能是嵌套的).分组号是从左到右计数的左括号数指定匹配的位置^ 匹配的是字符的开头,在多行检索中,匹配的是一行的开头$ 匹配的是字符的结尾,在多行检索中,匹配的是一行的结尾\b 匹配的是一个词语的边界.简而言之就是位于字符\w 和 \w之间的位置(注意:[\b]匹配的是退格符)\B 匹配的是非词语的边界的字符属性i 执行大小写不敏感的匹配g 执行一个全局的匹配,简而言之,就是找到所有的匹配,而不是在找到第一个之后就停止了举例1）最多 5 位小数的数字 — /^\d+(?:.\d{0,5})?$/onchange=”if(!/^\d+(?:.\d{0,5})?$/.test(this.value)){alert(‘只能输入数字’);this.value=’’;}”]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2019%2F10%2F05%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程和线程的区别线程是 CPU 最小的调度单元一个进程可以开启多个线程线程的 start 和 run 方法的区别start 会【调用 JVM_StartThread】创建一个新的子线程并启动run 只是 Thread 的一个普通方法调用Thread 和 Runnable 的关系Thread 类实现了 Runnable 接口创建线程的方法：实现 Runnable 接口 （推荐）继承 Thread 类如何实现处理线程的返回值主线程等待法使用 Thread.join() 阻塞当前线程以等待子线程处理完毕通过 Callable 接口实现，通过 FutureTask or 线程池获取线程的状态新建【new】运行【runnable】：running/ready ready–&gt; running无限期等待【waiting】限期等待【timed waiting】阻塞【blocked】结束【terminated】sleep 和 wait 的区别sleep:Thread.sleep(1000);线程休眠，让出 CPU，但是不释放对象锁，其他线程无法访问该对象wait:Object.wait()让出 CPU，释放对象锁，使得其他线程可以访问该对象进入到对象相关的等待池中notify 和 notifyall 的区别yield 函数目标线程由运行状态【running】转换为就绪状态【ready】,让出执行权限，让其他线程优先执行，但其他线程是否执行不确定，取决于操作系统interrupt 函数总结jdk 源码：hg.openjdk.java.net/jdk8u/jdk8u/jdk/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2F2019%2F09%2F02%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 异常体系RuntimeExceptionNullPointerExceptionClassCastExceptionIiilgalArgumentExceptionIndexOutOfBoundsExceptionNumberFormatException非 RuntimeExceptionClassNotFoundExceptionIOExceptionErrorNoClassDefFoundError成因：类以来的 class 或者 jar 不存在类文件存在，但是存在不同的域种大小写问题，javac 编译的时候是无视大小写的，很有可能编译出来的 class 文件就与想要的不一样StackOverflowErrorOutOfMemoryErrorJava 异常要点分析collection 体系ListVectorArrayListLinkedListSetHashSetTreeSetMapHashMapHashTableConcurrentHashMapJ.U.C包的梳理同步器CountDownLatchCyclicBarrierSemaphoreExchangerBlockingQueueArrayBlockingQueueLinkedBlockingQueuePriorityBlockingQueue…Java 的IO机制BIONIOChannelBufferSelectorAIO]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GVIM 配置文件]]></title>
    <url>%2F2019%2F08%2F27%2FwinVim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223" Windows兼容" 启用C-C,V,X"if has("gui_running")source $VIMRUNTIME/mswin.vim"endifbehave mswincolorscheme desert" 默认文件保存路径exec 'cd ' . fnameescape('C:\Users\Jayli\Documents\5.写作\')" 默认窗口大小set lines=42 columns=149" 设置字体set guifont=Consolas:h14" 关闭VI兼容模式set nocompatiblefiletype plugin indent onset modeline"set modelines=2" 缩写iab xdate =strftime("%Y-%m-%y")iab xdate1 =strftime("%Y-%m-%y %H:%M:%S")iab xname xue.f zhao" 打开文件后跳转到最后已知的文件位置，见帮助au BufReadPost * if line("'\"") &gt; 0|if line("'\"")" 自动进入二进制模式augroup Binaryau!au BufReadPre *.exe,*.dll let &amp;bin=1au BufReadPost *.exe,*.dll if &amp;bin | %!xxdau BufReadPost *.exe,*.dll set ft=xxd | endifau BufWritePre *.exe,*.dll if &amp;bin | %!xxd -rau BufWritePre *.exe,*.dll endifau BufWritePost *.exe,*.dll if &amp;bin | %!xxdau BufWritePost *.exe,*.dll set nomod | endifaugroup EN" 自动进入org模式au! BufRead,BufWrite,BufWritePost,BufNewFile *.orgau BufEnter *.org call org#SetOrgFileType()" 自动补全设置autocmd FileType python set omnifunc=pythoncomplete#Completeautocmd FileType python set completefunc=pythoncomplete#Completeautocmd FileType c set omnifunc=ccomplete#Completeautocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJSautocmd FileType html set omnifunc=htmlcomplete#CompleteTagsautocmd FileType xml set omnifunc=xmlcomplete#CompleteTagsautocmd FileType css set omnifunc=csscomplete#CompleteCSS" python文件使用空格缩进"au FileType python,c set shiftwidth=4 | set tabstop=4 | set expandtab | set softtabstop=4au FileType c set expandtab" 启用语法高亮syntax on" 高亮当前行set cursorline" 允许所有模式的虚拟编辑set ve=all" 自动补全只显示匹配项目set completeopt=menuset pumheight=10" Shell设置if has("unix")set shell=zshelse " under win32set shell=cmd.exe "d:/cygwin/cygwin.bat"endif" 历史记录数set history=400" 当文件被外部改变时自动读取set autoread" 总是使用鼠标set mouse=a" 取消自动备份set nobackupset writebackup" 设置Leaderlet mapleader = ","let g:mapleader = ","" 关闭IMEif has("gui")"set imdisableset iminsert=2set imsearch=0set noimcmdlineendif" vimrc编辑后自动重新加载autocmd! BufWritePost vimrc.zhao source $VIMHOME/vimrc.zhaoautocmd! BufWritePost vimrc.lang source $VIMHOME/vimrc.langautocmd! BufWritePost vimrc.face source $VIMHOME/vimrc.faceautocmd! BufWritePost vimrc.binding source $VIMHOME/vimrc.bindingautocmd! BufWritePost vimrc.plugin source $VIMHOME/vimrc.plugin" 设置swapfile存放路径set dir=.,$VIMTEMP" 保存撤销历史set undofileset undodir=$VIMHOME/undo" 光标上下两侧最少保留的屏幕行数set scrolloff=7" 启用命令行补全set wildmenu" 命令行区的高度set cmdheight=2" 显示标尺set ruler" 显示行号set number" 运行宏时不重画窗口set lazyredraw" 设置退格键模式set backspace=eol,start,indent" 设置左右移动光标的键的回绕set whichwrap+=,h,l" 搜索set ignorecaseset hlsearchset incsearch" 启用magicset magic" 禁用错误响铃set noerrorbellsset novisualbellset t_vb=" 显示匹配括号set showmatch" 设置自动缩进TAB数set shiftwidth=4" 设置TAB的空格数set tabstop=4" 使用空格代替TABset expandtab" 设置软TAB的空格数set softtabstop=4" 自动缩进set autoindent" 智能缩进set smartindent" C风格的缩进"set cindent" 禁用自动换行"set nowrap" 设置匹配符号组set matchpairs+=set matchpairs+==:;set matchpairs+=":"set matchpairs+=':'" 设置换行符格式"set ffs=dos,unix,mac" 显示tab和尾部空格"set listset listchars=tab:&gt;-,trail:$" 剪贴板if has("win32")"剪贴板等同于无名寄存器（*）set clipboard=unnamedendif"设置文件的代码形式 utf8set encoding=utf-8set termencoding=utf-8set fileencoding=utf-8set fileencodings=utf-8,ucs-bom,chinese,cp936,gb18030,big5,euc-jp,euc-kr,latin1"解决菜单乱码source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vim"解决consle输出乱码language messages zh_CN.utf-8"markdown设置"let g:table_mode_corner="|""pen file in chrome browser"nnoremap &lt;Leader&gt; ch :update&lt;Bar&gt;silent ! start %:p&lt;CR&gt;]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 获取 bean 的几种方式]]></title>
    <url>%2F2019%2F08%2F20%2FSpring-%E8%8E%B7%E5%8F%96-bean-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转自Spring在代码中获取bean的几种方式在初始化时保存ApplicationContext对象12ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");ac.getBean("beanId");说明：这种方式适用于采用Spring框架的独立应用程序，需要程序通过配置文件手工初始化Spring的情况。通过Spring提供的utils类获取ApplicationContext对象1234ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);ApplicationContext ac2 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);ac1.getBean("beanId");ac2.getBean("beanId");说明：这种方式适合于采用Spring框架的B/S系统，通过ServletContext对象获取ApplicationContext对象，然后在通过它获取需要的类实例。上面两个工具方式的区别是，前者在获取失败时抛出异常，后者返回null继承自抽象类ApplicationObjectSupport说明：抽象类ApplicationObjectSupport提供getApplicationContext()方法，可以方便的获取ApplicationContext。Spring初始化时，会通过该抽象类的setApplicationContext(ApplicationContext context)方法将ApplicationContext 对象注入。继承自抽象类WebApplicationObjectSupport说明：类似上面方法，调用getWebApplicationContext()获取WebApplicationContext实现接口ApplicationContextAware说明：实现该接口的setApplicationContext(ApplicationContext context)方法，并保存ApplicationContext 对象。Spring初始化时，会通过该方法将ApplicationContext对象注入。以下是实现ApplicationContextAware接口方式的代码，前面两种方法类似：12345678910111213141516171819202122232425262728public class SpringContextUtil implements ApplicationContextAware &#123;// Spring应用上下文环境private static ApplicationContext applicationContext;/*** 实现ApplicationContextAware接口的回调方法，设置上下文环境** @param applicationContext*/public void setApplicationContext(ApplicationContext applicationContext) &#123;SpringContextUtil.applicationContext = applicationContext;&#125;/*** @return ApplicationContext*/public static ApplicationContext getApplicationContext() &#123;return applicationContext;&#125;/*** 获取对象** @param name* @return Object* @throws BeansException*/public static Object getBean(String name) throws BeansException &#123;return applicationContext.getBean(name);&#125;&#125;虽然，spring提供的后三种方法可以实现在普通的类中继承或实现相应的类或接口来获取spring 的ApplicationContext对象，但是在使用是一定要注意实现了这些类或接口的普通java类一定要在Spring 的配置文件applicationContext.xml文件中进行配置。否则获取的ApplicationContext对象将为null。通过Spring提供的ContextLoader12WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext();wac.getBean(beanID);最后提供一种不依赖于servlet,不需要注入的方式。但是需要注意一点，在服务器启动时，Spring容器初始化时，不能通过以下方法获取Spring 容器，细节可以查看spring源码org.springframework.web.context.ContextLoader。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Service]]></title>
    <url>%2F2019%2F08%2F16%2FWeb-Service%2F</url>
    <content type="text"><![CDATA[Web Service 总结WSDL（网络服务描述语言，Web Services Description Language）WSDL 文档主要结构12345678910111213141516171819&lt;definitions&gt;&lt;types&gt; data type definitions........&lt;/types&gt;&lt;message&gt; definition of the data being communicated....&lt;/message&gt;&lt;portType&gt; set of operations......&lt;/portType&gt;&lt;binding&gt; protocol and data format specification....&lt;/binding&gt;&lt;/definitions&gt;WSDL 样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;wsdl:definitions name="nmtoken"? targetNamespace="uri"&gt; &lt;import namespace="uri" location="uri"/&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;wsdl:types&gt; ? &lt;wsdl:documentation .... /&gt; ? &lt;xsd:schema .... /&gt; * &lt;/wsdl:types&gt; &lt;wsdl:message name="ncname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;part name="ncname" element="qname"? type="qname"?/&gt; * &lt;/wsdl:message&gt; &lt;wsdl:portType name="ncname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;wsdl:operation name="ncname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;wsdl:input message="qname"&gt; ? &lt;wsdl:documentation .... /&gt; ? &lt;/wsdl:input&gt; &lt;wsdl:output message="qname"&gt; ? &lt;wsdl:documentation .... /&gt; ? &lt;/wsdl:output&gt; &lt;wsdl:fault name="ncname" message="qname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;/wsdl:fault&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:serviceType name="ncname"&gt; * &lt;wsdl:portType name="qname"/&gt; + &lt;/wsdl:serviceType&gt; &lt;wsdl:binding name="ncname" type="qname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;-- binding details --&gt; * &lt;wsdl:operation name="ncname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;-- binding details --&gt; * &lt;wsdl:input&gt; ? &lt;wsdl:documentation .... /&gt; ? &lt;-- binding details --&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; ? &lt;wsdl:documentation .... /&gt; ? &lt;-- binding details --&gt; * &lt;/wsdl:output&gt; &lt;wsdl:fault name="ncname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;-- binding details --&gt; * &lt;/wsdl:fault&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name="ncname" serviceType="qname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;wsdl:port name="ncname" binding="qname"&gt; * &lt;wsdl:documentation .... /&gt; ? &lt;-- address details --&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt;&lt;/wsdl:definitions&gt;SOAPSOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。或者更简单地说：SOAP 是用于访问网络服务的协议。soap 消息基本结构1234567891011121314151617&lt;?xml version="1.0"?&gt;&lt;soap:Envelopexmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;&lt;soap:Header&gt;...&lt;/soap:Header&gt;&lt;soap:Body&gt;... &lt;soap:Fault&gt; ... &lt;/soap:Fault&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;soap 实例soap 请求1234567891011121314151617POST /InStock HTTP/1.1Host: www.example.orgContent-Type: application/soap+xml; charset=utf-8Content-Length: nnn&lt;?xml version="1.0"?&gt;&lt;soap:Envelopexmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;&lt;soap:Body xmlns:m="http://www.example.org/stock"&gt; &lt;m:GetStockPrice&gt; &lt;m:StockName&gt;IBM&lt;/m:StockName&gt; &lt;/m:GetStockPrice&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;soap 响应12345678910111213141516HTTP/1.1 200 OKContent-Type: application/soap+xml; charset=utf-8Content-Length: nnn&lt;?xml version="1.0"?&gt;&lt;soap:Envelopexmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;&lt;soap:Body xmlns:m="http://www.example.org/stock"&gt; &lt;m:GetStockPriceResponse&gt; &lt;m:Price&gt;34.5&lt;/m:Price&gt; &lt;/m:GetStockPriceResponse&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;Web ServicesWeb Services 拥有三种基本的元素:SOAP、WSDL 以及 UDDI基础的 Web Services 平台是 XML + HTTP。HTTP 协议是最常用的因特网协议。XML 提供了一种可用于不同的平台和编程语言之间的语言。通过使用 Web services，您的应用程序可向全世界发布功能或消息。Web services 使用 XML 来编解码数据，并使用 SOAP 借由开放的协议来传输数据。通过 Web services，您的会计部门的 Win 2k 服务器可与 IT 供应商的 UNIX 服务器进行连接。参考：Web Service 教程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL编码]]></title>
    <url>%2F2019%2F08%2F15%2FURL%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[URL中文乱码解决方法。encodeURIComponent编码后java后台的解码解决方法一：JavaScript：window.self.location=”searchbytext.action?searchtext=”+encodeURIComponent(encodeURIComponent(seartext));java：searchtext=java.net.URLDecoder.decode(searchtext,”UTF-8”);为什么要两次编码的原因：后台java代码给searchtext赋值的时候，本身已经使用了一次解码，不过解码的结果依然不对。所以我们可以在页面上进行两次编码操作，这样后台自动的那次就可以抵消掉一次，然后在使用searchtext=java.net.URLDecoder.decode(searchtext,”UTF-8”);进行一次解码就好了。解决方法二：另外还有一种方法是JavaScript进行一次编码，后台java处理时换种想法就好了：java代码：String s = new String(request.getParameter(“name”).getBytes(“ISO8859-1”), “UTF-8”);参考资料：escape()、encodeURI()、encodeURIComponent()区别详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2019%2F08%2F10%2FJVM%2F</url>
    <content type="text"><![CDATA[主要内容：Java 官网，源码，类文件，类加载机制，类装载器，运行时数据区，内存结构模型，垃圾回收，JVM 参数，常用命令和工具JVM 前奏篇官网：www.oracle.comJava官方会针对不同的操作系统提供不同的 JVMJDK 包括 JRE，JRE 包括 JVM.java 编译后 –&gt; .class 类文件javac person.java –&gt; person.classjava person如何设计 javac 这款编译器？编译原理：词法分析器 —&gt; token 流语法分析器 —&gt; 语法树/抽象语法树语义分析器 —&gt; 注解语法树代码生成器 —&gt; 字节码1javap -c person.class &gt; person.txtsubline 查看 .class 文件cafe babe –&gt; 前 4 位标识 class 文件12345678910111213141516171819&gt; ClassFile &#123;&gt; u4 magic;&gt; u2 minor_version;&gt; u2 major_version;&gt; u2 constant_pool_count;&gt; cp_info constant_pool[constant_pool_count-1];&gt; u2 access_flags;&gt; u2 this_class;&gt; u2 super_class;&gt; u2 interfaces_count;&gt; u2 interfaces[interfaces_count];&gt; u2 fields_count;&gt; field_info fields[fields_count];&gt; u2 methods_count;&gt; method_info methods[methods_count];&gt; u2 attributes_count;&gt; attribute_info attributes[attributes_count];&gt; &#125;&gt;不同的语言，只要能转成符合 JVM 规范的 .class 文件，JVM 就能运行class 文件如何进入到 JVM 中运行？类装载机制JVM 会把 class 文件加载到内存对数据进行校验，转换，解析，初始化面向对象开发语言 class 文件—&gt; java.lang.Class 对象代表查找和导入 class 文件（用 ClassLoader 类去找）装载：通过一个类的全限定路径名，获取此类文件对应的二进制字节流—-》classLoader链接：将这个字节流对应的静态存储结构 转化为 方法区运行时数据结构—-》方法区初始化：Java 堆内存中 生产一个代表这个类的 java.lang.Class 对象—-》堆链接验证：保证被加载类的正确性。文件格式，元数据，字节码，符号引用准备：为类的静态变量分配内存，并将其初始化为默认值解析：把类中的符号引用转换为直接引用初始化对类的静态变量，静态代码块初始化当需要加载一个 class 文件时，从 bootstrap classLoader 开始往下加载若 bootstrap ClassLoader 加载到了，则子加载器不再加载；若 Bootstrap ClassLoader 没有加载到，则 Extension ClassLoader 加载…破坏双亲委派：自定义类加载时，不从 parent 开始加载Heap: 被所有线程共享，存储对象（包含普通的变量，全局变量，成员变量）对于方法而言，最重要的时被执行，如何才能被执行？主函数（主线程）中调用方法要被执行，一定是被线程所调用的Java 进程：包含很多线程，线程用于执行方法程序计数器Java 栈 （一个Java 虚拟机栈是与一个线程对应的，执行很多方法）本地方法栈（native）方法区：只有一个，被所有线程共享，堆的一部分，非堆运行时常量池类的信息，常量，静态变量作业：01-简述JDK，JRE，JVM之间的关系(最好结合官网的原话)JDK：Java development kit, Java 开发工具箱JRE：Java runtime environment，Java 运行环境JVM：Java virtual machine，Java 虚拟机JDK 包含 JRE，JRE 包含 JVM02-常用.class类文件的查看方式有哪些？用 javap 命令查看用反编译工具输出 java 文件查看用 subline 查看03-描述一下类加载机制的含义和过程含义：JVM 将类加载到内存中，使程序能够运行过程：查找类：根据全限定路径名，获取二进制字节流–&gt;将对应字节流的静态数据结构转化位动态的运行数据结构–&gt;在堆中生成实例对象链接：验证–&gt;准备–&gt;解析初始化：静态变量初始化04-说说你对Heap(堆)、Method Area(方法区)和Run-Time Constant Pool(运行时常量池)的理解(最好结合官网)Heap：被所有线程共享，存储实例对象。在 JVM 启动时创建。大小可以固定的，也可以按需增大减小。在内存中不需要连续存储空间。需要的空间超过可分配空间时会导致内存溢出。方法区：被所有线程共享，存储类结构（运行时常量池，属性，方法数据），方法代码，构造器等。在 JVM 气功时创建，逻辑上时堆的一部分。大小可以固定，也可以按需增大减小。在内存中不需要连续存储空间。需要的空间超过可分配空间时会导致内存溢出。常量池：是每个类或接口在运行时的表示，包含多种类型的常量。由方法区在 JVM 创建类或接口时分配空间。需要的空间超过可分配空间时会导致内存溢出。JVM 进行篇—JVM 内存模型结合类加载机制看 运行时数据区虚拟机栈，本地方法区，程序计数器 跟随线程的生命周期，是线程私有的，线程安全的堆，方法区跟随 JVM 进程的生命周期，是线程共享的，非线程安全的方法区（Metaspace）：存储类相关描述信息，常量，静态变量，即时编译器编译后的代码等数据堆：实例对象，数组虚拟机栈：方法（栈帧）程序计数器：记录当前线程执行方法的位置本地方法栈：标记的 native 方法栈帧：操作数栈，局部变量表，动态链接，方法返回地址操作数栈：ldc : 将常量从常量池中拿出来，压入操作数栈putfield：给对象字段赋值ldc2_w：将常量池中的常量（int,long,double）入操作数栈iconst_3：将 3 入操作数栈istore_0：将栈顶int类型的值保存到局部变量值 0 中iload_0：从局部变量 0 中装载 int 类型值入栈操作数栈https://www.jianshu.com/p/0cd8322a116b123查看jav进程 ：jps -l 可视化查看 JVM ：jvisualvm新创建的对象首先放 Eden 区，Eden 区放不下的大对象放 Old 区，Eden 区创建了很多对象，慢慢不够用了，有可能 Eden 区有没用的对象，触发垃圾回收（minor GC），释放一些空间出来。垃圾回收范围：整个 young 区（Eden，S0，S1）Eden 区垃圾回收后，一定确保 Eden 区是空的有些对象被回收掉一些对象仍然存活再次垃圾回收后回收 Eden 区，Eden 区为空某一个 S 区为空每次 GC ，对象的年龄都会 +1，对象年龄达到一定值后，移动到 Old 区Old 区不够用了，触发 Major GC（一次 Major GC 会包括一次 Minor GC）Major GC + Minor GC = Full GC如果 young 区不拆分成 Eden + S0 + S1 ：GC 之后，内存空间不连续Old 区对象越来越多，Major GC 频率增大，很耗性能两个 S 区：解决碎片化，内存空间不连续。需要保证 GC 后 Eden 区 和一个 S 区为空Eden ：S0：S1 = 8 : 1 : 1Minor GC 后从 Eden 区来的对象，S 区放不下，跟 Old 区借一些，分配担保机制宁可多次 Minor GC，减少 Major GC01-说说你对PC寄存器、Java虚拟机栈以及栈帧的理解PC 寄存器：用于记录线程中当前执行方法的位置Java 虚拟机栈：用于存放当前线程的调用方法，根据调用关系从 main 方法开始依次入栈，先进后出。栈帧：线程中一个方法对应一个栈帧，用于存放操作数，局部变量，动态链接，方法返回地址一个线程对应一个PC 寄存器，一个Java 虚拟机栈（包含多个栈帧）02-类的装载方式有哪些？new 对象装载ClassLoader 装载Class.forName 装载03-再次概括一下类加载机制的全过程，以及每个过程详细的操作加载根据全限定类名找到类对应的二进制字节流，遵从双亲委派原则，父加载器找到了类，则子加载器不再继续查找同类名的类。链接2.1 验证：对元数据，文件格式，符号引用，字节码进行验证，确保类的正确性2.2 准备：为静态变量分配内存，并赋值为类型的默认值2.3 解析：将类中的符号引用转化为能理解的直接引用初始化对静态变量，静态代码块初始化04-内存模型主要是针对运行时数据区哪两块区域的实现？内存模型结构是如何划分的？方法区和堆方法区+堆（Eden+S0+S1+Old）。其中 Eden ：S0：S1 = 8 ：1：1，Eden + S0 + S1 为 young 区。05-结合一个对象的一辈子，简述你对堆内存中的Eden，S0，S1和Old区的理解新产生的对象，首先进入 Eden 区，若对象过大，则将其放入 Old 区。当 Eden 区中的对象越来越多，会触发 Minor GC，一次 Minor GC 会将 Eden 中还存活的对象放入当前空白的 S0 区，将另一个非空的 S1 区中还存活的对象也移动到 S0 区，然后将现在空白的 S1 区变为 S0, 将非空的 S0 变为 S1。在 Minor GC 后存活的对象年龄都加 1，当对象年龄达到一定值后，将对象移动到 Old 区。当 Old 区的对象越来越多，达到一定阈值后触发 Major GC，清除掉 Old 区中没有存活的对象。一个 Major GC 会伴随着一次 Minor GC。young 区分为 Eden，S0，S1 是为了在 Minor GC 后释放出连续的存储空间，从而减少 Old 区对象的存放，降低 Major GC 的频率。JVM 升华篇—垃圾收集器类的装载方式有哪些？本地系统加载网络下载 .class 文件zip, jar， .class 文件DB 提取java 源码文件编译 classClass.forName()ClassLoader.loadClass() 加载应用—Java 进程—JVM 进程—JVM 实例—独立内存模型 ：一个堆，一个方法区，多个进程123jps -ljinfo -flag MaxHeapSize 进程id对象的占用空间组成（指针压缩：UseCompress）对象头（由操作系统的位数组成：32/64）实例数据（根据数据类型决定，对于引用类型的数据：32（4 byte）；64（6 byte））对齐填充（由虚拟机位数决定）垃圾回收判断一个对象是否是垃圾？引用计数法弊端：循环引用的问题，AB 相互持有引用，导致永远不能被回收可达性分析：某一个对象是否是垃圾，通过 Root 进行可达性分析有些对象永远不会被回收：Root 对象可用作 Root 的对象：类加载器，Thread, 虚拟机栈中的本地变量表，static 成员，常量引用，本地方法栈中的变量等进行垃圾回收Java 虽然是自动进行垃圾回收的 ，C/C++ 是手动进行垃圾回收的System.gc() —&gt; 可以让 JVM 进行一次垃圾回收：发出一个垃圾回收的指令，但是什么时候进行垃圾回收还是 JVM 决定垃圾回收策略/算法标记–清除：Mark–Sweep对内存空间做一个扫描，标记哪些对象是垃圾，再做一次扫描，清除垃圾内存空间不连续，空间碎片，从而导致 GC 频率增加标记和清除的空间扫描都比较消耗时间标记–复制内存空间分为大小相等的两部分，保持 50% 的空间的空白空间利用率低，造成空间浪费内存空间分为三部分 8：1：1新生代：对象朝生夕死，一次 GC 后绝大部分都死了，复制成本少，GC 效率高，从而降低 GC 频率标记–整理能够减少 GC 频率，相对连续的空间能够使用了，完全利用空间老年代对象存活时间较长，选择清除/整理算法Serial串行，jdk 1.3 之前，新生代唯一的一个选择只会用一个 CPU，单线程收集器，用一条垃圾线程去收集Parallel Scavenge: ParNew 基础上，更加关注系统的吞吐量吞吐量 === 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）ex: JVM 虚拟机总共运行了 100 分钟，垃圾收集用了 1 分钟，则吞吐量 = （100-1）/100吞吐量越高，意味着：垃圾收集时间越短，用户代码执行时间越长，用户代码就充分使用到了 CPU 的资源，尽快地完成运算任务GC 可以开启一个线程，也可以开启多个线程CMS：concurrent mark sweep 标记–清除初始标记 ：CMS initial mark，标记 GC Roots 能够关联到地对象，找出有多少个垃圾，存活对象。stop the world —&gt; 其他应用程序线程都暂停，很快单线程并发标记：进行 GC Root Tracing垃圾回收线程和用户线程能够同时进行，交替执行重新标记修改并发标记因用户程序变动的内容，stop the world多线程并发清除垃圾回收线程和用户线程能够同时进行，交替执行优点：并发收集—停顿时间少，低停顿—吞吐量 JVM 重点缺点产生大量空间碎片，并发阶段会降低吞吐量G1 ：标记—整理约定：保留老年代，新生代的概念。堆内存的布局—独立区域，大小相等的 region。新生代和老年代不再有物理上的隔离不会产生空间碎片指定可预测的停顿时间初始标记标记 GC Roots , TAMS 记录存活对象，暂停用户线程并发标记从 GC Roots 可达性分析最终标记根据用户期望的停顿时间，筛选回收筛选回收总结：垃圾收集器分类串行收集器：单个线程，并暂停用户线程，只能有一个垃圾回收线程。适用于内存比较小的嵌入式设备并行收集器（Parallel Scanvenge, parallel Old）：更加关注吞吐量多个垃圾回收线程并行工作，但是用户线程还是暂停等待状态。适用于科学计算，后台处理等若交互场景。并发收集器（CMS，G1）：更加关注停顿时间。用户线程和垃圾收集线程交替执行（同时执行），垃圾收集线程时不会暂停用户线程的执行。适用于相对时间有要求的场景，比如 Web 场景吞吐量和停顿时间：评价垃圾回收器好处的标准，调优的时候也是不断观察这两个参数的变化吞吐量 ：运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）停顿时间：垃圾收集器进行垃圾回收，终端应用执行响应的时间jdk 不同的版本G1 : jdk 1.7 开始使用, jdk 1.8 非常成熟 ，jdk 默认垃圾收集器，适用于新老生带123jps -ljinfo -flag UseG1GC 进程id如何选择垃圾收集器？优先调整堆的内存大小，让服务器自己选择如果内存大小 &lt; 100M ,使用串行收集器如果是单核，并且没有停顿时间要求，使用串行或 JVM 自己选如果允许停顿时间超过 1s，选择并行或则 JVM 自己选如果响应时间比较重要，并且不能超过 1s 停顿时间，使用并发收集器作业01-怎样确定一个对象为垃圾？1）引用计数，没有被引用的对象为垃圾。有弊端：对相互引用的对象无法判断为垃圾2）通过 Roots 对象进行可达性分析：有些对象永远不会被回收，例如 类加载器，Thread, 虚拟机栈中的局部变量表，静态成员变量，常量引用，本地方法栈中的变量等02-常用的垃圾回收算法有哪些？1）标记–清除：先全区扫描，标记垃圾对象，再一次全区扫描，清除垃圾对象。适用于 old 区。缺点是存在空间碎片，造成存储空间不连续，进而造成 GC 频率增大。2）标记–复制：保留一块空白的连续内存区，先扫描非空白区域，标记垃圾对象，再将存活的对象全部复制到空白的区域，连续存放。适用于young 区。解决了存储空间不连续的问题，缺点是总有一块空白区域存在，到 GC 的时候才会被使用，导致空间利用率低。3）标记–整理：先全区扫描，标记垃圾对象，再一次全区扫描，将移动存活对象，将其连续存放。适用于 old 区。解决了存储空间不连续的问题，缺点是全区扫描，消耗时间较长。03-说说常用的垃圾收集器，以及它们适用的区域和特点Serial GC，Serial Old：jdk 1.3 以前用的是 Serial GC，单线程，GC 进程运行时会暂停用户进程。适用于内存比较小的嵌入式设备Parallel Scanvenge, parallel Old：在 ParaNew 基础上更多关注吞吐量。多线程 GC，GC 进程运行时会暂停用户进程。适用于科学计算，后台应用等弱交互的场景。CMS，G1：更多关注停顿时间。并行 GC，GC 进程运行时不会暂停用户进程时间很短，可以与用户进程并发标记和并发清理。适用于对停顿时间有要求的场景，例如 Web 场景。04-简述你对吞吐量和停顿时间的理解吞吐量 = 用户代码运行时间/(用户代码运行时间 + GC 时间)停顿时间：GC 回收时，终端应用执行的响应时间吞吐量和停顿时间用于评价 GC 性能的好坏，JVM 调优时也是观察这两个参数的变化JVM 实战篇JVM 参数和工具JVM 参数标准参数：不同的 jdk 版本，是一样的-version， -help-X 参数：java -Xint -version-Xint-Xcomp-Xmixed-XX 参数Boolean 类型：-XX:+UseG1GC -XX:+UseConcMarkSweepGC非 Boolean 类型: -XX:=-XX:InitialHeapSize=100M其他类型:简写Xms100M -XX:InitialHeapSize=100MXmx100M -XX:MaxHeapSize=100MXss100k -XX:ThreadStackSize=100k ===&gt; 虚拟机栈帧大小查看当前 java 进程中，参数有多少个？java -XX:+PrintFlagsFinal -version:= 表示参数进行过修改常用命令https://docs.oracle.com/apps/search/search.jsp?q=jinfo&amp;category=javajdk/bin: javac java javadoc javap单位：byte1234567891Byte (字节) = 8bit (位)1KB = 1024Byte(字节)1MB = 1024KB1GB = 1024MB1TB = 1024GBjps: 查看系统中有的 java 进程数 —&gt;PIDjps -ljinfo: 查看实时 JVM 参数,某一个 Java 进程 JVM 参数的值。实时设置 JVM 参数jinfo -flag JVM参数 进程IDjinfo -flags 进程IDjstat: 查看 JVM 虚拟机性能统计信息jstat -class 18044 1000 10jstat -gc 18044 1000 10jstack: 查看当前线程堆栈信息jstack 18044jmap：堆内存信息jmap -heap PID当生产环境发生 OOM，能够自动导出 heap 文件，便于分析哪里出现了问题（用 Eclipse MAT 查看）jmap -dump:format=b,file=heap.hprof PID &lt;==&gt; -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof代替命令操作的工具jdk/binjconsolejvisualvm查看远程服务器的信息ps -ef|grep tomcatJMX – 生产服务器中监听一个端口配置远程服务器 catalina.sh开启防火墙，配置安全组，允许以下端口访问方法区 metaspace 信息，生成类相关信息stackOverFlowError: 栈帧溢出, 默认 7956JVM 参数设置虚拟机栈容量：-Xss128k优先让 JVM 默认值（合理值：3000-5000）太小：栈会经常溢出太大：机器硬件性能能够容量的线程数量是有限的jstack pid ：查看到死锁原因非堆里面也会有垃圾，也会进行垃圾收集，但是我们更多关注的是堆的垃圾收集GC 什么时候进行？JVM 自动完成的，根据 JVM 系统环境而定的，时机是不确定的System.gc() 发出一个信号，什么时候 GC 还是等待 JVM 执行Eden 区或 S 区不够用了Old 区不够用了方法区 MetaSpace 不够用了JVM 终结篇gcviewer 工具 : https://gceasy.io01-JVM常用的参数类型有哪些？1) 标准参数，如 -version, -help2) -X 参数，如 -Xint, -Xmixed, -Xcomp3) -XX Boolean 类型, 如 -XX:UseG1GC; -XX 非 Boolean 类型，如 -XX:InitialHeapSize=100M4) 其他类型，简写，如 Xms100M 等价于 -XX:InitialHeapSize=100M02-JVM中常用的命令和工具有哪些，并说出它们的作用？1）命令：​ jps: 查看系统中所有 Java 进程​ jinfo: 查看实时的 JVM 参数，实时设置 JVM 参数​ jstat: 查看 JVM 性能统计信息​ jstack: 查看当前线程堆栈信息​ jmap: 查看堆信息，可设置堆内存溢出时导出 dump 文件2）工具: jdk/bin 中的工具 jconsole，jvisualvm 。不用命令行即可在图形化界面查看 JVM 信息，Java 进程信息等，也可远程连接，查看远程服务的 JVM 信息。03-如果让你代码演示一下堆，方法区的内存溢出，你会怎么做和配置？堆内存溢出：先设置较小的堆内存（ 如 Xmx50M），启动应用后不断产生对象而不销毁，使 Old 区中对象一直累积最终溢出方法区内存溢出：先设置较小的方法区内存（如 -XX:MaxPermSize=30M），启动应用后不断产生常量，静态变量等，使方法区一直累积最终溢出04-虚拟机栈中方法递归调用了会怎么样？线程死锁可以用什么命令查看？虚拟机栈中方法递归调用次数过多，超出虚拟机栈深度，会导致虚拟机栈溢出 StackOverFlowError。线程死锁可用命令 jstack PID 查看05-演示一下tomcat启动时gc日志的打印结果，最好能截图放到作业中，配置参数我提供给大家XX:+Printetails -XX:+PrintGCTimeStamps -XX:+PrintateStamps-Xloggc:$CATALINA_HOME/logs/gc.log-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:$CATALINA_HOME/logs/gc.log]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 笔记]]></title>
    <url>%2F2019%2F08%2F02%2FSpring%20Boot%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习笔记。一、Spring Boot 入门1、Spring Boot 简介简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案；2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；单体应用：ALL IN ONE微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；详细参照微服务文档3、环境准备http://www.gulixueyuan.com/ 谷粒学院环境约束–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS–SpringBoot 1.5.9.RELEASE：1.5.9；统一环境；1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt;2、IDEA设置整合maven进来；4、Spring Boot HelloWorld一个功能：浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125;4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125;5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;将这个应用打成jar包，直接使用java -jar的命令进行执行；5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本；Spring Boot的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;spring-boot-starter-==web==：​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125;@SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;@SpringBootConfiguration:Spring Boot的配置类；​ 标注在某个类上，表示这是一个Spring Boot的配置类；​ @Configuration:配置类上来标注这个注解；​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component@EnableAutoConfiguration：开启自动配置功能；​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;​ @AutoConfigurationPackage：自动配置包​ @Import(AutoConfigurationPackages.Registrar.class)：​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==​ @Import(EnableAutoConfigurationImportSelector.class)；​ 给容器中导入组件？​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器；​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；​==Spring注解版（谷粒学院）==6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；选择我们需要的模块；向导会联网创建Spring Boot项目；默认生成的Spring Boot项目；主程序已经生成好了，我们只需要我们自己的逻辑resources文件夹中目录结构static：保存所有的静态资源； js css images；templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；2、STS使用 Spring Starter Project快速创建项目二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的；•application.properties•application.yml配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；YAML（YAML Ain’t Markup Language）​ YAML A Markup Language：是一个标记语言​ YAML isn’t Markup Language：不是一个标记语言；标记语言：​ 以前的配置文件；大多都使用的是 xxxx.xml文件；​ YAML：以数据为中心，比json、xml等更适合做配置文件；​ YAML：配置例子12server: port: 8081​ XML：123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt;2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的123server: port: 8081 path: /hello属性和值也是大小写敏感；2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写；​ 字符串默认不用加上单引号或者双引号；​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进​ 对象还是k: v的方式123friends: lastName: zhangsan age: 20行内写法：1friends: &#123;lastName: zhangsan,age: 18&#125;数组（List、Set）：用- 值表示数组中的一个元素1234pets: - cat - dog - pig行内写法1pets: [cat,dog,pig]3、配置文件值注入配置文件123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12javaBean：1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;我们可以导入配置文件处理器，以后编写配置就有提示了123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;1、properties配置文件在idea中默认utf-8可能会乱码调整2、@Value获取值和@ConfigurationProperties获取值比较@ConfigurationProperties@Value功能批量注入配置文件中的属性一个个指定松散绑定（松散语法）支持不支持SpEL不支持支持JSR303数据校验支持不支持复杂类型封装支持不支持配置文件yml还是properties他们都能获取到值；如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件；1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss;@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效不来编写Spring的配置文件12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt;SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式1、配置类@Configuration——&gt;Spring配置文件2、使用@Bean给容器中添加组件12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125;##4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=155、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml默认使用application.properties的配置；2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev​ 2、命令行：​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；​ 可以直接在测试的时候，配置传入命令行参数​ 3、虚拟机参数；​ -Dspring.profiles.active=dev6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件–file:./config/–file:./–classpath:/config/–classpath:/优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件；互补配置；==我们还可以通过spring.config.location来改变默认的配置文件位置==项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==1.命令行参数所有的配置都可以在命令行上进行指定java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc多个配置用空格分开； –配置项=值2.来自java:comp/env的JNDI属性3.Java系统属性（System.getProperties()）4.操作系统环境变量5.RandomValuePropertySource配置的random.*属性值==由jar包外向jar包内进行寻找；====优先加载带profile==6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件==再来加载不带profile==8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件10.@Configuration注解类上的@PropertySource11.通过SpringApplication.setDefaultProperties指定的默认属性所有支持的配置加载来源；参考官方文档8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理；配置文件能配置的属性参照1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==2）、@EnableAutoConfiguration 作用：利用EnableAutoConfigurationImportSelector给容器中导入一些组件？可以查看selectImports()方法的内容；Listconfigurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；3）、每一个自动配置类进行自动配置功能；4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125;根据当前不同的条件判断，决定这个配置类是否生效？一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");精髓：​ 1）、SpringBoot启动会加载大量的自动配置类​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；xxxxAutoConfigurartion：自动配置类；给容器中添加组件xxxxProperties:封装配置文件中相关属性；2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；@Conditional扩展注解作用（判断是否满足当前指定条件）@ConditionalOnJava系统的java版本是否符合要求@ConditionalOnBean容器中存在指定Bean；@ConditionalOnMissingBean容器中不存在指定Bean；@ConditionalOnExpression满足SpEL表达式指定@ConditionalOnClass系统中有指定的类@ConditionalOnMissingClass系统中没有指定的类@ConditionalOnSingleCandidate容器中只有一个指定的Bean，或者这个Bean是首选Bean@ConditionalOnProperty系统中指定的属性是否有指定的值@ConditionalOnResource类路径下是否存在指定资源文件@ConditionalOnWebApplication当前是web环境@ConditionalOnNotWebApplication当前不是web环境@ConditionalOnJndiJNDI存在指定项自动配置类必须在一定的条件下才能生效；我们怎么知道哪些自动配置类生效；==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效；1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)三、日志1、日志框架小张；开发一个大型系统；​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；​ 5、JDBC—数据库驱动；​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；市面上的日志框架；JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….日志门面 （日志的抽象层）日志实现JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-loggingLog4j JUL（java.util.logging） Log4j2 Logback左边选一个门面（抽象层）、右边来选一个实现；日志门面： SLF4J；日志实现：Logback；SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘​ ==SpringBoot选用 SLF4j和logback；==2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；给系统里面导入slf4j的jar和 logback的实现jar123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125;图示；每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？如何让系统中所有的日志都统一到slf4j；==1、将系统中其他日志框架先排除出去；====2、用中间包来替换原有的日志框架；====3、我们导入slf4j其他的实现==3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;SpringBoot使用它来做日志功能；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt;底层依赖关系总结：​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录​ 2）、SpringBoot也把其他的日志都替换成了slf4j；​ 3）、中间替换包？123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory();​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？​ Spring框架用的是commons-logging；12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志；123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125;日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%nlogging.filelogging.pathExampleDescription(none)(none)只在控制台输出指定文件名(none)my.log输出日志到my.log文件(none)指定目录/var/log输出到指定目录的 spring.log 文件中2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了Logging SystemCustomizationLogbacklogback-spring.xml, logback-spring.groovy, logback.xml or logback.groovyLog4j2log4j2-spring.xml or log4j2.xmlJDK (Java Util Logging)logging.propertieslogback.xml：直接就被日志框架识别了；logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt;如：12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt;如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误no applicable action for [springProfile]5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换；slf4j+log4j的方式；12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt;切换为log4j2123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;四、Web开发1、简介使用SpringBoot；1）、创建SpringBoot应用，选中我们需要的模块；2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来3）、自己编写业务代码；自动配置原理？这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容；2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125;==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；==​ webjars：以jar包的方式引入静态资源；http://www.webjars.org/localhost:8080/webjars/jquery/3.3.1/jquery.js123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt;==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射==12345"classpath:/META-INF/resources/", "classpath:/resources/","classpath:/static/", "classpath:/public/" "/"：当前项目的根路径localhost:8080/abc === 去静态资源文件夹里面找abc==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；==​ localhost:8080/ 找index页面==4）、所有的 **/favicon.ico 都是在静态资源文件下找；==3、模板引擎JSP、Velocity、Freemarker、ThymeleafSpringBoot推荐的Thymeleaf；语法更简单，功能更强大；1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt;2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; //只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；使用：1、导入thymeleaf的名称空间1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;2、使用thymeleaf语法；123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3、语法规则1）、th:text；改变当前元素里面的文本内容；​ th：任意html属性；来替换原生属性的值2）、表达式？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）==Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））ContentNegotiatingViewResolver：组合所有的视图解析器的；==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjarsStatic index.html support. 静态首页访问Custom Favicon support (see below). favicon.ico自动注册了 of Converter, GenericConverter, Formatter beans.Converter：转换器； public String hello(User user)：类型转换使用ConverterFormatter 格式化器； 2017.12.17===Date；12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125;​ ==自己添加的格式化器转换器，我们只需要放在容器中即可==Support for HttpMessageConverters (see below).HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则Automatic use of a ConfigurableWebBindingInitializer bean (see below).==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==12初始化WebDataBinder；请求数据=====JavaBean；org.springframework.boot.autoconfigure.web：web的所有自动场景；If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==;既保留了所有的自动配置，也能用我们扩展的配置；1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125;原理：​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125;​ 3）、容器中所有的WebMvcConfigurer都会一起起作用；​ 4）、我们的配置类也会被调用；​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用；3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了我们需要在配置类中添加@EnableWebMvc即可；123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125;原理：为什么@EnableWebMvc自动配置就失效了；1）@EnableWebMvc的核心12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;2）、12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;3）、12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；5、如何修改SpringBoot的默认配置模式：​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125;2）、国际化1）、编写国际化配置文件；2）、使用ResourceBundleMessageSource管理国际化资源文件3）、在页面使用fmt:message取出国际化内容步骤：1）、编写国际化配置文件，抽取页面需要显示的国际化消息2）、SpringBoot自动配置好了管理国际化资源文件的组件；12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125;3）、去页面获取国际化的值；123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;效果：根据浏览器语言设置的信息切换了国际化；原理：​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化4）、点击链接切换国际化12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125;3）、登陆开发期间模板引擎页面修改以后，要实时生效1）、禁用模板引擎的缓存12# 禁用缓存spring.thymeleaf.cache=false2）、页面修改完成以后ctrl+f9：重新编译；登陆错误消息的显示1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt;4）、拦截器进行登陆检查拦截器12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125;注册拦截器1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125;5）、CRUD-员工列表实验要求：1）、RestfulCRUD：CRUD满足Rest风格；URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作普通CRUD（uri来区分操作）RestfulCRUD查询getEmpemp—GET添加addEmp?xxxemp—POST修改updateEmp?id=xxx&amp;xxx=xxemp/{id}—PUT删除deleteEmp?id=1emp/{id}—DELETE2）、实验的请求架构;实验功能请求URI请求方式查询所有员工empsGET查询某个员工(来到修改页面)emp/1GET来到添加页面empGET添加员工empPOST来到修改页面（查出员工进行信息回显）emp/1GET修改员工empPUT删除员工emp/1DELETE3）、员工列表：thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；三种引入公共片段的th属性：th:insert：将公共片段整个插入到声明引入的元素中th:replace：将声明引入的元素替换为公共片段th:include：将被引入的片段的内容包含进这个标签中1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;引入片段的时候传入参数：123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt;6）、CRUD-员工添加添加页面123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt;提交的数据格式不对：生日：日期；2017-12-12；2017/12/12；2017.12.12；日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;2017-12-12—Date； 类型转换，格式化;默认日期是按照/的方式；7）、CRUD-员工修改修改添加二合一表单123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt;8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt;7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果：​ 1）、浏览器，返回一个默认的错误页面浏览器发送请求的请求头：​ 2）、如果是其他客户端，默认响应一个json数据​ 原理：​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；给容器中添加了以下组件 ​ 1、DefaultErrorAttributes：1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125;​ 2、BasicErrorController：处理默认/error请求12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125;​ 3、ErrorPageCustomizer：12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）​ 4、DefaultErrorViewResolver：123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125;​ 步骤：​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理；​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的；1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125;2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面；​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；​ 页面能获取的信息；​ timestamp：时间戳​ status：状态码​ error：错误提示​ exception：异常对象​ message：异常消息​ errors：JSR303数据校验的错误都在这里​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据；12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果...​ 2）、转发到/error进行自适应响应效果处理1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125;3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；自定义ErrorAttributes1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125;最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；问题？1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125;2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。注册三大组件用以下方式ServletRegistrationBean123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125;FilterRegistrationBean1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125;ServletListenerRegistrationBean12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125;SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；DispatcherServletAutoConfiguration中：1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125;2）、SpringBoot能不能支持其他的Servlet容器；3）、替换为其他嵌入式Servlet容器默认支持：Tomcat（默认使用）12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt;Jetty1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt;Undertow1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt;4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125;1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125;2）、EmbeddedServletContainer：（嵌入式的Servlet容器）3）、以TomcatEmbeddedServletContainerFactory为例123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125;4）、我们对嵌入式容器的配置修改是怎么生效？1ServerProperties、EmbeddedServletContainerCustomizerEmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？怎么修改的原理？5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器步骤：1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；只要是嵌入式的Servlet容器工厂，后置处理器就工作；3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法###5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；获取嵌入式的Servlet容器工厂：1）、SpringBoot应用启动运行run方法2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext3）、refresh(context);刷新刚才创建好的ioc容器；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125;4）、 onRefresh(); web的ioc容器重写了onRefresh方法5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer();6）、获取嵌入式的Servlet容器工厂：EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());8）、嵌入式的Servlet容器创建对象并启动Servlet容器；先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；==IOC容器启动创建嵌入式的Servlet容器==9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar​ 优点：简单、便携；​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；步骤1）、必须创建一个war项目；（利用idea创建好目录结构）2）、将嵌入式的Tomcat指定为provided；12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125;4）、启动服务器就可以使用；原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；servlet3.0（Spring注解版）：8.2.4 Shared libraries / runtimes pluggability：规则：​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；流程：1）、启动Tomcat2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；4）、每一个WebApplicationInitializer都调用自己的onStartup；5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125;7）、Spring的应用就启动并且创建IOC容器1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125;==启动Servlet容器，再启动SpringBoot应用==五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；docker客户端(Client)：连接docker主机进行操作；docker仓库(Registry)：用来保存各种打包好的软件镜像；docker镜像(Images)：软件打包好的镜像；放在docker仓库中；docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用使用Docker的步骤：1）、安装Docker2）、去Docker仓库找到这个软件对应的镜像；3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；4）、对容器的启动停止就是对软件的启动停止；3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）；​ 2）、导入虚拟机文件centos7-atguigu.ova；​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆​ 4）、使用客户端连接linux服务器进行命令操作；​ 5）、设置虚拟机网络；​ 桥接网络===选好网卡====接入网线；​ 6）、设置好网络以后使用命令重启虚拟机的网络1service network restart​ 7）、查看linux的ip地址1ip addr​ 8）、使用客户端连接linux；2）、在linux虚拟机上安装docker步骤：12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker4、Docker常用命令&amp;操作1）、镜像操作操作命令说明检索docker search 关键字 eg：docker search redis我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。拉取docker pull 镜像名:tag:tag是可选的，tag表示标签，多为软件的版本，默认是latest列表docker images查看所有本地镜像删除docker rmi image-id删除指定的本地镜像https://hub.docker.com/2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；步骤：1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档3）、安装MySQL示例1docker pull mysql错误的启动1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个正确的启动12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01做了端口映射12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02几个其他的高级操作123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver效果：​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；​ 数据源的相关配置都在DataSourceProperties里面；自动配置原理：org.springframework.boot.autoconfigure.jdbc：1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；2、SpringBoot默认可以支持；1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、3、自定义数据源类型1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125;4、DataSourceInitializer：ApplicationListener；​ 作用：​ 1）、runSchemaScripts();运行建表语句；​ 2）、runDataScripts();运行插入数据的sql语句；默认只需要将文件命名为：123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置5、操作数据库：自动配置了JdbcTemplate操作数据库2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;步骤：​ 1）、配置数据源相关属性（见上一节Druid）​ 2）、给数据库建表​ 3）、创建JavaBean4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125;问题：自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125;123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125;5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置更多使用参照http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/4、整合SpringData JPA1）、SpringData简介2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）；1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email;2）、编写一个Dao接口来操作实体类对应的数据表（Repository）123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125;3）、基本的配置JpaProperties1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true七、启动配置原理几个重要的事件回调机制配置在META-INF/spring.factoriesApplicationContextInitializerSpringApplicationRunListener只需要放在ioc容器中ApplicationRunnerCommandLineRunner启动流程：1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125;2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125;3、事件监听机制配置在META-INF/spring.factoriesApplicationContextInitializer123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125;SpringApplicationRunListener123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125;配置（META-INF/spring.factories）12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener只需要放在ioc容器中ApplicationRunner1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125;CommandLineRunner1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125;八、自定义starterstarter：​ 1、这个场景需要使用到的依赖是什么？​ 2、如何编写自动配置12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\​ 3、模式：启动器只用来做依赖导入；专门来写一个自动配置模块；启动器依赖自动配置；别人只需要引入启动器（starter）mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter步骤：1）、启动器模块12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;2）、自动配置模块123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125;123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125;12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125;更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 使用 package 来包装存储过程]]></title>
    <url>%2F2019%2F07%2F10%2Foracle-%E4%BD%BF%E7%94%A8-package-%E6%9D%A5%E5%8C%85%E8%A3%85%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[oracle使用package来包装存储过程为什么使用 package如果是存储过程或者function数量比较多维护起来就麻烦了，存储过程或者function单独建名称是不允许重复的，有时还会误删引起不必要的麻烦。oracle也提供了package这种机制来处理这种问题，package和java里的那个很相似，里面既可以定义存储过程还可以定义function,package由包头和包体两部分组成。包头部分，主要是包的定义以及存储过程声明1234567create or replace package user_control Asprocedure insert_user(fid In user.id%TYPE,fname In user.name%TYPE,fout Out varchar2); End user_control;包体部分，主要是存储过程的具体实现，创建包体的时候注意包体的名称和包的名称一致1234567891011create or replace package user_control Asprocedure insert_user(fid In user.id%TYPE,fname In user.name%TYPE,fout Out varchar2)ISbegininsert into user(id,name) values(fid,fname);fout := '1';end;end user_control;调用存储过程，包名.存储过程名(参数列表)12345678910111213oracle调用： declare fout varchar2(2); begin user_control.insert_user('001','jack',fout); end; mybatis调用： &lt;select id="insertUser" statementType="CALLABLE" parameterType="java.util.Map"&gt; &#123;call user_control.insert_user(#&#123;fid,mode=IN,jdbcType=VARCHAR&#125;,#&#123;fname,mode=IN,jdbcType=VARCHAR&#125;,#&#123;fout,mode=OUT,jdbcType=VARCHAR&#125;)&#125; &lt;/select&gt;]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE Errors]]></title>
    <url>%2F2019%2F07%2F01%2FVUE-Errors%2F</url>
    <content type="text"><![CDATA[VUE 错误总结。Module build failed (from ./node_modules/postcss-loader/src/index.js):Error: Loading PostCSS Plugin failed: Cannot find module ‘./features/input-number’ ‘./features/input-number’删掉 node_modules，重新 npm install‘vue-cli-service’ 不是内部或外部命令，也不是可运行的程序或批处理文件。卸载 vue-cli: npm uninstall -g @vue/cli安装 vue-cli: npm install -g @vue/cli]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[数据库基础总结。数据库事务特性 (ACID)原子性，atomicity：最小的执行单元，不可再分，要么全部成功，要么全部失败，通过 undo log 来实现一致性，consistent：不破坏数据库的约束，不破坏自定义的约束隔离性，isolation：各个事务对表的操作相互独立，互不影响持久性，durable：commit 后的数据保存到磁盘，不会因为服务重启儿丢失数据，通过 redo log 来实现数据库事务隔离级别读未提交，read uncommitted：可能出现脏读，未解决任何问题读已提交，read committed：解决了脏读问题，可能出现不可重复读可重复读，repeatable read：解决了不可重复读问题，可能出现幻读串行化，serializable：解决了所有问题脏读：同一个事务中两次读取，读取到另一个事务未提交的数据不可重复读：同一个事务两次读取，两次读取间隔中有另一个事务提交了数据（update/delete），导致前后读取的数据不一致幻读：同一个事务中两次读取，两次读取间隔中有另一个事务插入的数据（insert），导致前后读取的数据不一致MySQL 查询语句的执行过程客户端连接 MySQL 服务器查询缓存解析器解析 SQL：词法解析，语法解析，语义分析，预处理器 -&gt; 解析数查询优化器生成执行计划查询执行引擎调用存储引擎的 API 获取到数据返回查询结果：缓存结果，返回结果建立索引的原则：最左匹配原则 &gt; 离散性高原则 &gt; 最少空间原则表中有 name 索引，where name like ‘abc%’ 可以用到索引吗？答：不一定，在查询优化阶段会进到数据抽样环节，但是数据抽样的环节判定该列的数据离散性不高也有可能导致不走索引而进行全表扫描。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中的网络Qos]]></title>
    <url>%2F2019%2F06%2F25%2F27.%20%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CQoS%2F</url>
    <content type="text"><![CDATA[控制网络的 QoS无类别排队规则基于类别的排队规则控制 Qos对于进入的流量，可以设置策略 Ingress policy；对于发出的流量，可以设置 QoS 规则 Egress shaping，支持 HTB。小结云中的流量控制主要通过队列进行的，队列分为两大类：无类别队列规则和基于类别的队列规则。在云中网络 Openvswitch 中，主要使用的是分层令牌桶规则（HTB），将总的带宽在一棵树上按照配置的比例进行分配，并且在一个分支不用的时候，可以借给另外的分支，从而增强带宽利用率。思考这一节中提到，入口流量其实没有办法控制，出口流量是可以很好控制的，你能想出一个控制云中的虚拟机的入口流量的方式吗？安全性和流量控制大概解决了，但是不同用户在物理网络的隔离还是没有解决，你知道怎么解决吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中网络]]></title>
    <url>%2F2019%2F06%2F25%2F24.%20%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[虚拟网卡的原理虚拟网卡连接到云中共享与互通隔离灵活小结云计算的关键技术是虚拟化，这里我们重点关注的是，虚拟网卡通过打开 TUN/TAP 字符设备的方式，将虚拟机内外连接起来云中的网络重点关注四个方面，共享、隔离、互通、灵活。其中共享和互通有两种常用的方式，分别是桥接和 NAT，隔离可以通过 VLAN 的方式思考为了直观，这一节的内容我们以桌面虚拟化系统举例。在数据中心里面，有一款著名的开源软件 OpenStack，这一节讲的网络连通方式对应 OpenStack 中的哪些模型呢？这一节的最后，我们也提到了，本节提到的网络配置方式比较不灵活，你知道什么更加灵活的方式吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中的网络安全]]></title>
    <url>%2F2019%2F06%2F25%2F26.%20%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[公有云网络安全对于公有云上的虚拟机，我的建议是仅仅开放需要的端口，而将其他的端口一概关闭。这个时候，你只要通过安全措施守护好这个唯一的入口就可以了。采用的方式常常是用 ACL （Access Control List，访问控制列表）来控制 IP 和端口。网络包进入一台机器过程内核模块 ip_tablesconntrack（连接跟踪），filter（数据包过滤），nat（网络地址转换），mangle（数据包修改）nat 表主要是处理网络地址转换，可以进行 Snat（改变数据包的源地址）、Dnat（改变数据包的目标地址）表和链表iptables 的表分为四种：raw–&gt;mangle–&gt;nat–&gt;filter。这四个优先级依次降低，raw 不常用，所以主要功能都在其他三种表里实现。每个表可以设置多个链。云平台安装 iptables 配置小结云中的安全策略的常用方式是，使用 iptables 的规则，请记住它的五个阶段，PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING。iptables 分为四种表，raw、mangle、nat、filter。其中安全策略主要在 filter 表中实现，而虚拟网络和物理网络地址的转换主要在 nat 表中实现。思考这一节中重点讲了 iptables 的 filter 和 nat 功能，iptables 还可以通过 QUEUE 实现负载均衡，你知道怎么做吗？这一节仅仅讲述了云中偷窥的问题，如果是一个合法的用户，但是不自觉抢占网络通道，应该采取什么策略呢？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2P协议]]></title>
    <url>%2F2019%2F06%2F25%2FP2P%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[P2P 协议总结。下载文件通过 HTTP 下载通过 FTP 下载，FTP 建立两个 TCP 连接来传输一个文件通过 P2P 下载FTP 的两种工作模式在 FTP 服务器的角度来说主动模式（PORT）客户端随机打开一个大于 1024 的端口 N，向服务器 21 端口发起连接，同时开放 N+1 端口监听，并将 N+1 端口告知服务器，由服务器从自己的数据端口 20 主动连接客户端的数据端口 N+1被动模式（PASV）客户端打开两个大于 1024 的任意端口 N 和 N+1，第一个端口连接服务器的 21 端口，提交 PASV 命令。然后服务器打开一个大于 1024 的任意端口 P，并告知客户端。客户端从 N+1 端口连接服务器 P 端口，进行数据传输种子（.torrent）文件.torrent 文件由 announce（tracker URL）和 文件信息组成文件信息内容如下info 区：该种子有几个文件，文件有多长，目录结构，目录及文件名Name 字段：顶层目录名每个段大小段哈希值：将整个种子中，每段的 SHA-1 哈希值拼在一起下载文件时，BT 客户端先解析.torrent 文件，得到 tracker 地址，然后连接 tracker 服务器，tracker 服务器回应下载者的请求，将其他下载者的 IP 提供给下载者，下载者再连接其他下载者，根据 .torrent 文件，两者分别告知对方自己已经有的段，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。但是 tracker 服务器是弊端 ，一旦 tracker 服务器出现问题，BT 工具就无法工作去中心化网络（DHT，Distributed Hash Table）任何一个 BitTorrent 启动后，它都有两个角色，一个是 peer，监听一个 TCP 端口，用来上传和下载文件，这个角色表名，我这里有某个文件。另一个角色 DHT node，监听一个 UDP 端口，通过这个角色，这个节点加入了一个 DHT 的网络DHT 网络里，每个 DHT node 都有一个 ID，每个 DHT node 都有责任掌握一些信息，即文件索引，即它应该知道某些文件是保存在哪些节点上，而它本身不一定就是保存这个文件的节点DHT node ID 是一个随机选择的 160 bits(20字节) 空间，文件的哈希也使用这样的 160 bits 空间小结下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；一种是基于分布式的哈希算法，元数据和文件数据全部分散思考除了这种去中心化分布式哈希的算法，你还能想到其他的应用场景吗？在前面的所有章节中，要下载一个文件，都需要使用域名。但是网络通信是使用 IP 的，那你知道怎么实现两者的映射机制吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议串讲]]></title>
    <url>%2F2019%2F06%2F25%2F37.%20%E4%B8%B2%E8%AE%B2%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[基本概念BGP 路由广播CDN 内容分发网络Open vSwitchOVSVXLANVPCIPsec VPNPaas 服务智能 DNSHSSMMESGWPGWGLSBSLBvarnish 缓存CIDR 子网掩码HAProxyCAS（Compare and Set，乐观锁）部署高可用高并发的电商平台公网 IP 通知到全世界手机网上，域名解析得 IP 地址购物之前看图片，静态资源 CDN点下单，双方建立连接下单请求网络包12345678910111213POST /purchaseOrder HTTP/1.1Host: www.geektime.comContent-Type: application/json; charset=utf-8Content-Length: nnn &#123; "order": &#123; "date": "2018-07-01", "className": " 趣谈网络协议 ", "Author": " 刘超 ", "price": "68" &#125;&#125;网络流控拥塞与重传数据中心进网关，公网 NAT 成私网进入隧道打标签，RPC 远程调用下单下单扣减库存，数据入库返回成功Restful API 要求幂等]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中网络隔离]]></title>
    <url>%2F2019%2F06%2F25%2F28.%20%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9A%94%E7%A6%BBGRE%E3%80%81VXLAN%2F</url>
    <content type="text"><![CDATA[云中网络隔离底层的物理网络设备组成的网络我们称为 Underlay 网络，而用于虚拟机和云中的这些技术组成的网络称为 Overlay 网络，这是一种基于物理网络的虚拟化网络实现。GRE全称 Generic Routing Encapsulation，它是一种 IP-over-IP 的隧道技术。它将 IP 包封装在 GRE 包里，外面加上 IP 头，在隧道的一端封装数据包，并在通路上进行传输，到另外一端的时候解封装。你可以认为 Tunnel 是一个虚拟的、点对点的连接。缺点：GRE 是一种点对点隧道，如果有三个网络，就需要在每两个网络之间建立一个隧道。如果网络数目增多，这样隧道的数目会呈指数性增长。GRE 不支持组播有很多防火墙和三层网络设备无法解析 GRE，因此它们无法对 GRE 封装包做合适地过滤和负载均衡。VXLAN技术融入云平台小结要对不同用户的网络进行隔离，解决 VLAN 数目有限的问题，需要通过 Overlay 的方式，常用的有 GRE 和 VXLAN。GRE 是一种点对点的隧道模式，VXLAN 支持组播的隧道模式，它们都要在某个 Tunnel Endpoint 进行封装和解封装，来实现跨物理机的互通。OpenvSwitch 可以作为 Tunnel Endpoint，通过设置流表的规则，将虚拟机网络和物理机网络进行隔离、转换。思考虽然 VXLAN 可以支持组播，但是如果虚拟机数目比较多，在 Overlay 网络里面，广播风暴问题依然会很严重，你能想到什么办法解决这个问题吗？基于虚拟机的云比较复杂，而且虚拟机里面的网卡，到物理网络转换层次比较多，有一种比虚拟机更加轻量级的云的模式，你知道是什么吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议]]></title>
    <url>%2F2019%2F06%2F25%2F14.%20HTTP%20%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP 协议HTTP 协议是应用层最常用的协议http://www.163.com 是个 URL，叫做统一资源定位符。http 是协议，www.163.com 是域名，表示互联网上的一个位置，通过 DNS 服务器解析为具体的 IP 地址HTTP 请求过程HTTP 请求准备将域名发送给 DNS 服务器，解析为具体的 IP 地址建立 TCP 连接，三次握手在 HTTP 1.1 的协议里面，默认是 keep-alive 。所以建立的 TCP 连接，可以在多次请求中复用。HTTP 请求构建HTTP 请求格式请求行方法：GET [获取信息]，POST [向服务器传输信息，新建]，PUT [向服务器上传更新信息，更新]，DELETE [删除资源]URL：统一资源定位符，不是 IP版本：HTTP 协议版本首部以 key-value 的形式设置信息，彼此通过冒号分隔。例如：Accept-Charset，表示客户端可以接受的字符集Content-Type，表示正文格式Cache-control，控制缓存HTTP 请求发送TCP 层在发送报文的时候，在 IP 头添加源 IP 地址和目标 IP 地址，交给 IP 层传输IP 层判断目标地址是否和自己在同一局域网，若是，则发送 ARP 协议请求该目标 IP 地址的 MAC 地址，若不是，则发送 ARP 协议请求网关的 MAC 地址。将源 MAC 地址和目标 MAC 地址放到 MAC 头，发送出去网关接收到包，确定目标 MAC 地址和自己一致后，根据目标 IP 地址，找到下一跳路由器的 MAC 地址并设置为目标 MAC 地址，将包发送给下一跳路由器不断执行上一步直到到达目标 IP 地址的局域网网关，网关发送 ARP ，获取到目标地址的 MAC 地址，将包发送出去目标服务器解析 TCP 头的端口号，通过端口号将包发给相应的进程处理HTTP 返回HTTP 返回报文格式返回过程和请求过程类似HTTP 2.0HTTP 2.0 对 HTTP 的头进行一定的压缩，将原来每次需要携带的大量 key-value 在服务器和客户端建立一个索引表，对相同的头，只发送索引表中的索引HTTP 2.0 将一个 TCP 连接请求，切分成多个流，每个流有自己的 IDHTTP 2.0 将传输信息分割为更小的消息和帧。常见的帧有 Header 帧和 Data 帧，每个 Header 帧会开启一个新的流，同一个流里面有多个 Data 帧每个帧可以乱序发送，通过帧首部的流标识符组装HTTP 2.0 解决了 HTTP 1.1 的首部阻塞问题，减少了 TCP 连接数对服务器性能的影响QUIC 协议HTTP 2.0 还是基于 TCP 协议的，在处理包的时候有严格的顺序，依旧会存在帧阻塞的问题QUIC 协议基于 UDP 协议机制一：自定义连接以一个 64 位随机数作为 ID 标识连接机制二：自定义重传发送的数据流设置偏移量 offset机制三：无阻塞的多路复用在自定义连接和重传机制的基础上，解决了多路复用机制四：自定义流量控制当前收到的最大 offset 到当前的 stream 所能容纳的最大缓存，是窗口大小小结HTTP 协议是基于 TCP 实现的HTTP 协议头部标识的重要方法：GET, POST, PUT, DELETEHTTP 2.0 通过头压缩，分帧，二进制编码，多路复用等技术提升性能QUIC 协议是 Google 创造的，通过基于 UDP 自定义类似 TCP 的连接，重传，多路复用，流量控制技术，进一步提升性能思考QUIC 是一个精巧的协议，所以它肯定不止今天提到的四种机制，你知道它还有哪些吗？这一节主要讲了如何基于 HTTP 浏览网页，如果要传输比较敏感的银行卡信息，该怎么办呢？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS 协议]]></title>
    <url>%2F2019%2F06%2F25%2F18.%20DNS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DNS（Domain Name System）服务器需要高可用，高并发，分布式，于是，有了数状的层次结构根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址权威 DNS 服务器：返回相应主机的 IP 地址DNS 解析流程本地 DNS 服务器由网络服务商（ISP），如电信，移动等自动分配，它通常就在网络服务商的某个机房负载均衡内部负载均衡在域名解析的时候，配置策略，返回不同的 IP 地址全局负载均衡（GSLB，Global Server Load Balance）对不需要做全局负载均衡的简单应用，yourcompany.com 的权威 DNS 服务器可以直接将 object.yourcompany.com 这个域名解析为一个或者多个 IP 地址，然后客户端通过多个 IP 地址，进行简单的轮训，实现简单的负载均衡对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局网络负载均衡机制，因此需要专门的设备或者服务器来做这件事情，这就是全局负载均衡器（GSLB）图中第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，得知用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 object.yd.yourcompany.com，盖住本地 DNS 服务器去请求第二层的 GSLB第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个内部负载均衡（SLB，Server Load Balancer）的地址返回给本地 DNS 服务器本地 DNS 服务器将结果返回给本地 DNS 解析器本地 DNS 解析器将结果缓存后，返回给客户端客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡小结DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡思考全局负载均衡为什么要分地址和运营商呢？全局负载均衡使用过程中，常常遇到失灵的情况吗？对应应该怎么来解决呢？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDN]]></title>
    <url>%2F2019%2F06%2F25%2F20.%20CDN%2F</url>
    <content type="text"><![CDATA[CDN 架构客户端如何找到边缘节点CDN 缓存流媒体 CDN 防盗链：HTTP 头的 refer 字段设置信息时间戳防盗链客户端取出当前的时间戳，要访问的资源及其路径，连同加密字符串进行签名算法得到一个字符串，然后生成一个下载链接，带上这个签名字符串和截止时间戳去访问 CDN。在 CDN 服务端，根据取出过期时间，和当前 CDN 节点时间进行比较，确认请求是否过期。然后 CDN 服务端有了资源及路径，时间戳，以及约定的加密字符串，根据相同的签名算法计算签名，如果匹配则一致，访问合法，才会将资源返回给客户。动态 CDN 模式生鲜超市模式，即边缘计算模式既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。冷链运输模式，即路径优化模式数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。小结CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。思考这一节讲了 CDN 使用 DNS 进行全局负载均衡的例子，CDN 如何使用 HTTPDNS 呢？客户端对 DNS、HTTPDNS、CDN 访问了半天，还没进数据中心，你知道数据中心里面什么样吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS 协议]]></title>
    <url>%2F2019%2F06%2F25%2F15.%20HTTPS%20%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTPS 协议使用加密算法解决 HTTP 协议的明文传输对称加密加密和解密的密钥一样，安全性不高，速度快非对称加密密钥分为公钥和私钥，加解密的密钥不一样，安全性高，速度慢由权威机构 [CA, Certificate Authority]颁发证书。证书里面有公钥，证书所有者，证书发布机构，证书有效期，签名算法权威机构会用它的私钥给证书签名得到证书后，用 CA 公钥解密证书签名，获取里面的公钥CA 公钥验证： CA 的上级证书的公钥，一直到 root CA，做最后的背书。通过层层授信背书，保证非对称加密模式的正常运转。HTTPS 协议工作模式重放与篡改Timestamp 和 Nonce 随机数 保证唯一性，只会接收一次，多次收到相同的 Timestamp 和 Nonce 则视为无效小结加密分为对称加密和非对称加密。对称加密效率高，但是解决不了密钥。传输的问题；非对称加密可以解决这个问题，但是效率不高非对称加密需要通过证书和权威机构来验证公钥的合法性HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率思考HTTPS 协议比较复杂，沟通过程太过繁琐，这样会导致效率问题，你知道有哪些手段可以解决这些问题吗？HTTP 和 HTTPS 协议的正文部分传输个 JSON 什么的还好，如果播放视频，就有问题了，那这个时候，应该使用什么协议呢？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据中心]]></title>
    <url>%2F2019%2F06%2F25%2F21.%20%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[数据中心TOR(Top Of Rack) 交换机网卡高可用交换机堆叠核心交换机环路问题大二层TRILL(Treansparent Interconnection of Lots of Link) 多链接透明互联协议把三层的路由能力模拟在二层实现大二层广播整个数据中心网络结构小结数据中心分为三层。服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过 TRILL 协议。随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。思考对于数据中心来讲，高可用是非常重要的，每个设备都要考虑高可用，那跨机房的高可用，你知道应该怎么做吗？前面说的浏览新闻、购物、下载、看视频等行为，都是普通用户通过公网访问数据中心里面的资源。那 IT 管理员应该通过什么样的方式访问数据中心呢？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPDNS]]></title>
    <url>%2F2019%2F06%2F25%2F19.%20HTTPDNS%2F</url>
    <content type="text"><![CDATA[传统 DNS 的问题域名缓存问题域名转发问题出口 NAT(网络地址转换) 问题一旦做了网络地址转换，权威的 DNS 服务器就没办法通过 IP 地址，来判断客户到底来自哪个运营商，很可能因为转换后的 IP 地址，误判运营商，导致跨运营商的访问域名更新问题解析延迟问题HTTPDNS 的工作模式不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。HTTPDNS 的缓存设计同步更新实时性好，但是如果有多个请求都发现过期的时候，同时会请求 HTTPDNS 多次，浪费资源异步更新可以将多个都过期的合并为一个 HTTPDNS 请求，只执行一次，减少 HTTPDNS 的压力。但是更新不实时可能拿到过期数据HTTPDNS 调度设计在客户端，SDK 会收集网络请求数据，如容错率、请求时间等网络请求质量数据，并发送到统计后台，进行分析聚合，以此查看不同的 IP 的服务质量在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级，权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的，时延低的 IP 地址小结传统的 DNS 有很多问题，例如解析慢，更新不及时。因为缓存，转发，NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能调度思考使用 HTTPDNS，需要向 HTTPDNS 服务器请求解析域名，可是客户端怎么知道 HTTPDNS 服务器的地址或者域名呢？HTTPDNS 的只能调度，主要是让客户端选择最近的服务器，而有一种机制，使得资源分发到里客户端更近的位置，从而加快客户端的访问，你知道是什么技术吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN]]></title>
    <url>%2F2019%2F06%2F25%2F22.%20VPN%2F</url>
    <content type="text"><![CDATA[VPN （Virtual Private network）虚拟专用网VPN 工作原理VPN 通过隧道技术在公网上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，里面涉及到三种协议：乘客协议，隧道协议，承载协议基于私密性，完整性，真实性，组成了 IPsec VPN 的协议簇IPsec VPN 建立过程建立 IKE 自己的 SA建立 IPsec SA打包封装传输传输过程ATM 技术ATM 是传输之前先建立一个连接，形成一个虚拟的通路，一旦连接建立了，所有的包都按照相同的路径走，不会分头行事MPLS（Multi-Protocol Label Switching）多协议标签交换总结VPN 可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些MPLS-VPN 综合和 IP 转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买思考当前业务的高可用性和弹性伸缩很重要，所以很多机构都会在自建私有云之外，采购公有云，你知道私有云和公有云应该如何打通吗？前面所有的上网行为，都是基于电脑的，但是移动互联网越来越成为核心，你知道手机上网都需要哪些协议吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动网络]]></title>
    <url>%2F2019%2F06%2F25%2F23.%20%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[移动网络的发展历程2G 网络MS：Mobile StationBSS：Base Station Subsystem，基站子系统RAN：Radio Access Network，无线接入网BTS：Base Transceiver Station ，基站收发信台BSC：Base Station Controller，基站控制器CN：Core Network，核心网NSS：Network and Switching Subsystem，网络子系统MSC：Mobile Service Switching Center，移动业务交换中心AUC：Authentication Center，鉴权中心EIR：Equipment Identity Register，设备识别寄存器VLR：Visit Location Register，访问位置寄存器，表示目前在的地方HLR：Home Location Register，归属位置寄存器，表示号码归属地GMSC：Gateway Mobile Switching Cente，网关移动交换中心PSTN：Public Switched Telephone Network，公共交换电话网手机通过无线信号连接基站基站一面朝前接无线，一面朝后接核心网核心网一面朝前接基站请求，一是判断你是否合法，而是判断你是不是本地号，还有没有钱，一面朝后通过网关连接电话网络2.5G 网络PCU：Packet Control Unit，分组控制单元，用以提供分组交换通道SGSN：Service GPRS Supported NodeGGSN：Gateway GPRS Supported Node在原来的电路交换基础上，加了分组交换业务，支持 Packet 的转发，从而支持 IP 网络3G 网络RNC：Radio Network Controller无线通信技术有了改进，大大增加了无线的带宽4G 网络HSS 用于存储用户签约信息的数据库，其实就是你这个号码归属地是哪里的，以及一些认证信息。MME 是核心控制网元，是控制面的核心，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息，判断你是否合法。如果允许连上来，MME 不负责具体的数据的流量，而是 MME 会选择数据面的 SGW 和 PGW，然后告诉 eNodeB，我允许你连上来了，你连接它们吧。于是手机直接通过 eNodeB 连接 SGW，连上核心网，SGW 相当于数据面的接待员，并通过 PGW 连到 IP 网络。PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用来控制上网策略和流量的计费。4G 网络协议解析控制面协议 SCTP 认证鉴权SCTP 也是面向连接的传输层协议，更适合移动网络。它继承了 TCP 较为完善的拥塞控制并改进 TCP 的一些不足之处SCTP 特点：多宿主将一个联合分成多个流四次握手，防止 SYN 攻击消息分帧断开连接是三次挥手控制面协议 GTP-C 建立数据通路GTP-C 协议是基于 UDP 的数据面协议 GTP-U当两个隧道都打通，接在一起的时候，PGW 会给手机分配一个 IP 地址，这个 IP 地址是隧道内部的 IP 地址，可以类比为 IPsec 协议里面的 IP 地址。这个 IP 地址是归手机运营商管理的。然后，手机可以使用这个 IP 地址，连接 eNodeB，从 eNodeB 经过 S1-U 协议，通过第一段隧道到达 SGW，再从 SGW 经过 S8 协议，通过第二段隧道到达 PGW，然后通过 PGW 连接到互联网。GTP-U 隧道封装格式：手机上网流程异地上网问题SGW 是你本地的运营商的设备PGW 是你所属的运营商的设备这样判断你是否能上网的在国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的 IP 地址也是国内运营商里统计的。运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算。由于你的上网策略是由国内运营商在 PCRF 中控制的，因而你还是上不了脸书。小结移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变请记住 4G 网络的结构，有 eNodeB、MME、SGW、PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书思考咱们上网都有套餐，有交钱多的，有交钱少的，你知道移动网络是如何控制不同优先级的用户的上网流量的吗？前面讲过的所有的网络都是基于物理机的，随着云计算兴起，无论是电商，还是移动网络都要部署在云中了，你知道云中网络的设计有哪些要点吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件定义网络]]></title>
    <url>%2F2019%2F06%2F25%2F25.%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[软件定义网络 （SDN）SDN 主要特点控制与转发分离控制平面与转发平面之间的开放接口逻辑上的集中控制OpenFlow 和 OpenSwitchOpenFlow 是 SDN 控制器和网络设备之间互通的南向接口协议，OpenvSwitch 用于创建软件的虚拟交换机。OpenvSwitch 是支持 OpenFlow 协议的，当然也有一些硬件交换机也支持 OpenFlow 协议。它们都可以被统一的 SDN 控制器管理，从而实现物理机和虚拟机的网络连通。在 OpenvSwitch 里面，有一个流表规则，任何通过这个交换机的包，都会经过这些规则进行处理，从而接收、转发、放弃。通过这些表格，可以对收到的网络包随意处理。总而言之，对于 OpenvSwitch 来讲，网络包到了我手里，就是一个 Buffer，我想怎么改怎么改，想发到哪个端口就发送到哪个端口。实验实验一：用 OpenvSwitch 实现 VLAN 的功能实验二：用 OpenvSwitch 模拟网卡绑定，连接交换机在 OpenvSwitch 里面，有个 bond_mode，可以设置为以下三个值：active-backup：一个连接是 active，其他的是 backup，当 active 失效的时候，backup 顶上；balance-slb：流量安装源 MAC 和 output VLAN 进行负载均衡；balance-tcp：必须在支持 LACP 协议的情况下才可以，可根据 L2, L3, L4 进行负载均衡。OpenSwitch 架构图如何在云计算中使用 OpenSwitch小结用 SDN 控制整个云里面的网络，就像小区保安从总控室管理整个物业是一样的，将控制面和数据面进行了分离一种开源的虚拟交换机的实现 OpenvSwitch，它能对经过自己的包做任意修改，从而使得云对网络的控制十分灵活将 OpenvSwitch 引入了云之后，可以使得配置简单而灵活，并且可以解耦物理网络和虚拟网络思考在这一节中，提到了通过 VIP 可以通过流表在不同的机器之间实现复杂均衡，你知道怎样才能做到吗？虽然 OpenvSwitch 可以解耦物理网络和虚拟网络，但是在物理网络里面使用 VLAN，数目还是不够，你知道该怎么办吗？]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F06%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式学习总结。创建型模式简单工厂模式不同实例对象有共同的基类。工厂负责根据入参创建不同的实例对象，返回的是实例对象的基类。类比：类的构造方法重载工厂方法模式不同工厂实现不同产品实例对象的创建，这些工厂共有一个工厂基类。工厂基类中定义创建产品的公共方法。不同产品共有一个产品基类，不同工厂的创建产品方法返回类型为产品基类。类比：jdbc 创建连接12Connection conn=DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");Statement statement=conn.createStatement();抽象工厂模式角色：一个抽象工厂，具体工厂，多个抽象产品（产品等级结构），具体产品。抽象工厂里面定义创建不同抽象产品的方法。具体工厂实现方法创建具体产品，一个具体工厂里面创建的所有产品组成一个产品族，这些产品有不同的产品基类。能够很方便的生成不同的产品族，只需要新增加一个具体工厂；但是当有新的抽象产品出现时，需要更改抽象工厂，以及抽象工厂的每一个具体工厂子类。类比：页面更换主题时，字体，颜色，按钮等会一起更换当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。建造者模式角色：抽象建造者，具体建造者，指挥者，产品角色指挥者根据抽象建造者编程，安排建造顺序，使得相同的创建过程可以创建不同类型的产品。类比：汽车组装工厂单例模式单例类的构造函数为私有，防止通过 new 来创建多个对象；提供一个自身的静态私有成员变量，存储单例对象；提供一个公有的静态工厂方法，在生成对象前检查是否已经存在对象，确保生成一个对象类比：全局ID生成器结构型模式适配器模式角色：目标抽象类，适配器类，适配者类，客户类适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为适配者的相应接口的调用类比：电源适配器，转接口适配器桥接模式角色：抽象类，扩充抽象类，实现类接口，具体实现类抽象类中与实现类接口为关联关系而不是继承关系，使得抽象化与实现化脱耦类比：跨平台视频播放器，可以在不同操作系统播放不同格式的文件装饰模式角色：抽象构件，具体构件，抽象装饰类，具体装饰类抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。类比：变形金刚，拥有基本功能，还可以根据需要产生新的功能外观模式角色：一个外观角色，多个子系统角色客户访问子系统统一通过外观角色访问，由外观角色分配请求给具体的子系统类比：网关，controller 层享元模式角色：抽象享元类，具体享元类，非共享具体享元类，享元工厂类抽象享元类声明一个接口，通过它可以接受并作用于外部状态；具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。类比：JVM 中创建的 Class 类对象代理模式角色：抽象主题角色，代理主题角色，真实主题角色抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。动态代理：不知道真实主题角色的情况下代理主题角色类比：日志框架，spring AOP, jumpserver, 防火墙行为型模式命令模式角色：抽象命令类，具体命令类，调用者，接收者，客户类抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。类比：批量命令脚本，存储过程中介者模式角色：抽象中介者，具体中介者，抽象同事类，具体同事类抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。类比：ESB 服务总线，MVC 中的 controller 控制 view 和 model 的交互观察者模式角色：目标，具体目标，观察者，具体观察者目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。类比：发布订阅，listenner，一对多的对象交互状态模式角色：环境类，抽象状态类，具体状态类环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。类比：TCP协议连接的多状态，case策略模式角色：环境类，抽象策略类，具体策略类环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。类比：封装的不同排序算法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts-JSP传值]]></title>
    <url>%2F2019%2F06%2F03%2FStruts-JSP%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[Action –&gt; JSPAction 中申明成员变量, extends ActionSupport为该成员变量设置 getter 方法JSP 中通过 ${get方法后面的值} 获取12345678后端 Action：private List&lt;Map&lt;String, String&gt;&gt; amazon850InfoList;public List&lt;Map&lt;String, String&gt;&gt; getAmazon850InfoList222() &#123; return amazon850InfoList;&#125;前端 JSP：$&#123;Amazon850InfoList222&#125; 即为 amazon850InfoList 传入的值JSP –&gt; ActionAction 中申明成员变量, extends ActionSupport为该成员变量设置 setter 方法JSP 中通过 ${set方法后面的值} 设置值前端 JSP： src=&quot;amazonProcessAction!queryAmazon850Info?poNumber=&apos; + po + &apos;&quot; 后端 Action： 方法 1： String poNumber = ServletActionContext.getRequest().getParameter(&quot;poNumber&quot;); 方法 2： private String poNumber222; public void setPoNumber(String poNumber) { this.poNumber222 = poNumber; } poNumber222 的值即为 poNumber 的值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Google Java编程风格规范]]></title>
    <url>%2F2019%2F06%2F02%2Fgoogle-java-style%2F</url>
    <content type="text"><![CDATA[转自 @Hawstein出处 http://hawstein.com/2014/01/20/google-java-style/前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。术语说明在本文档中，除非另有说明：术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。其他的术语说明会偶尔在后面的文档出现。指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。源文件基础文件名源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。文件编码：UTF-8源文件编码格式为UTF-8。特殊字符空白字符除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：所有其它字符串中的空白字符都要进行转义。制表符不用于缩进。特殊转义序列对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。例如：12345String unitAbbrev = "μs"; | 赞，即使没有注释也非常清晰String unitAbbrev = "\u03bcs"; // "μs" | 允许，但没有理由要这样做String unitAbbrev = "\u03bcs"; // Greek letter mu, "s" | 允许，但这样做显得笨拙还容易出错String unitAbbrev = "\u03bcs"; | 很糟，读者根本看不出这是什么return '\ufeff' + content; // byte order mark | Good，对于非打印字符，使用转义，并在必要时写上注释Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)源文件结构一个源文件包含(按顺序地)：许可证或版权信息(如有需要)package语句import语句一个顶级类(只有一个)以上每个部分之间用一个空行隔开。许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。package语句package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)import语句import不要使用通配符即，不要出现类似这样的import语句：import java.util.*;不要换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)顺序和间距import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：所有的静态导入独立成组com.google imports(仅当这个源文件是在com.google包下)第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sunjava importsjavax imports组内不空行，按字典序排列。类声明只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。例外：package-info.java，该文件中可没有package-info类。类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。格式术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。大括号使用大括号(即使是可选的)大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):左大括号前不换行左大括号后换行右大括号前换行如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。示例：1234567891011return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; &#125;&#125;;4.8.1节给出了enum类的一些例外。空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。示例：1void doNothing() &#123;&#125;块缩进：2个空格每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)一行一个语句每个语句后要换行。列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。例外：不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。package和import语句(见3.2节和3.3节)。注释中那些可能被剪切并粘贴到shell中的命令行。自动换行术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e)如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。方法名或构造函数名与左括号留在同一行。逗号(,)与其前面的内容留在同一行。自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。空白垂直空白以下情况需要使用一个空行：类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。在函数体内，语句的逻辑分组间使用空行。类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。要满足本文档中其他节的空行要求(比如3.3节：import语句)多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。分隔任何保留字与其前面的右大括号(})(如else, catch)。在任何左大括号前({)，两个例外：@SomeAnnotation({a, b})(不使用空格)。String[][] x = foo;(大括号间没有空格，见下面的Note)。在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。catch块中的管道符号(catch (FooException | BarException e)。foreach语句中的分号。在, : ;及右括号())后如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。类型和变量之间：List list。数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。以下示例先展示未对齐的代码，然后是对齐的代码：12345private int x; // this is fineprivate Color color; // this tooprivate int x; // permitted, but future editsprivate Color color; // may leave it unalignedTip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。具体结构枚举类枚举常量间用逗号隔开，换行可选。没有方法和文档的枚举类可写成数组初始化的格式：1private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。变量声明每次只声明一个变量不要使用组合声明，比如int a, b;。需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。数组数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的：1234567891011121314151617new int[] &#123; 0, 1, 2, 3 &#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[]&#123;0, 1, 2, 3&#125;非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。缩进与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。Fall-through：注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125;default的情况要写出来每个switch语句都包含一个default语句组，即使它什么代码也不包含。注解(Annotations)注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125;例外：单个的注解可以和签名的第一行出现在同一行。例如：1@Override public int hashCode() &#123; ... &#125;应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：1@Partial @Mock DataLoader loader;参数和局部变量注解没有特定规则。注释块注释风格块注释与其周围的代码在同一缩进级别。它们可以是/* ... */风格，也可以是// ...风格。对于多行的/* ... */注释，后续行必须从*开始， 并且与前一行的*对齐。以下示例注释都是OK的。1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */注释不要封闭在由星号或其它字符绘制的框架里。Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 /* ... */。Modifiers类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。1public protected private abstract static final transient volatile synchronized native strictfp命名约定对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。标识符类型的规则包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。类名类名都以UpperCamelCase风格编写。类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。方法名方法名都以lowerCamelCase风格编写。方法名通常是动词或动词短语。下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;;这些名字通常是名词或名词短语。非常量字段名非常量字段名以lowerCamelCase风格编写。这些名字通常是名词或名词短语。参数名参数名以lowerCamelCase风格编写。参数应该避免用单个字符命名。局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。类型变量名类型变量可用以下两种风格之一进行命名：单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。名字从散文形式(prose form)开始:把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：每个单词的第一个字母都大写，来得到大驼峰式命名。除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。最后将所有的单词连接起来得到一个标识符。示例：12345678Prose form Correct Incorrect------------------------------------------------------------------"XML HTTP request" XmlHttpRequest XMLHTTPRequest"new customer ID" newCustomerId newCustomerID"inner stopwatch" innerStopwatch innerStopWatch"supports IPv6 on iOS?" supportsIpv6OnIos supportsIPv6OnIOS"YouTube importer" YouTubeImporter YoutubeImporter*加星号处表示可以，但不推荐。Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。编程实践@Override：能用则用只要是合法的，就把@Override注解给用上。捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123; // it's not numeric; that's fine, just continue&#125;return handleTextResponse(response);例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125;静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。1234Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very badFinalizers: 禁用极少会去重写Object.finalize。Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。Javadoc格式一般形式Javadoc块的基本格式如下所示：12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125;或者是以下单行形式：1/** An especially short bit of Javadoc. */基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。段落空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或This method returns...开头, 它也不会是一个完整的祈使句，如Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。例外：重写如果一个方法重写了超类中的方法，那么Javadoc并非必需的。可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 日常命令]]></title>
    <url>%2F2019%2F05%2F15%2FGit-%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[日常 Git 命令提交本地代码到远程数据库:给master赋予权限12切换到项目目录下: $ cd F:\\chenzhen\\git\\B2BGit\\B2B赋予提交代码到远程库权限: $ git config remote.origin.push refs/heads/*:refs/for/*已修改文件加入暂存区git add…提交暂存区文件到本地仓库git commit -m “提交注释…”推送到远程仓库git push本地指定分支推送到远程指定分支git push origin local-branch:refs/for/remote-branch修改上笔提交的注释git commit –amend -m “新的注释…”撤销历史提交git reset [commit-id]git pull 时 error: Your local changes to the following files would be overwritten by merge:123git stash save "stash注释"git pullgit stash pop重置当前分支到指定历史位置git reset –soft [commit-id]遴选git cherry-pick change-id]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 语句]]></title>
    <url>%2F2019%2F05%2F12%2FSQL-%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[SQL 语句总结。关联表更新1234MERGE INTO 表2 USING 表1ON ( 表2.A = 表1.A ) -- 条件是 A 相同WHEN MATCHED THEN UPDATE SET 表2.C = 表1.B -- 匹配的时候，更新条件判断1decode(字段,条件1,表达式1,条件2,表达式2,…表达式n)正则查找12没有找到返回 0regexp_instr('1010000123', '\D')正则替换12去掉字符串前面的 0regexp_replace(l.materialnumber,'^[0]+','')将全为数字的字符串前面的 0 去掉12SELECT decode(regexp_instr('1010000123', '\D'), 0, regexp_replace('1010000123', '^[0]+', ''), '1010000123') FROM dual查看表锁1234567891011121314151617181920--查询锁表原因SELECT l.session_id sid, s.serial#, l.locked_mode, l.oracle_username, s.user#, l.os_user_name, s.machine, s.terminal, a.sql_text, a.action FROM v$sqlarea a, v$session s, v$locked_object l WHERE l.session_id = s.sid AND s.prev_sql_addr = a.address ORDER BY sid, s.serial#; --解决办法alter system kill session '2888,44'; --即spid，serial快速复制表结构1create table new_table_name as select * from old_table_name where 1=2;快速插入数据1INSERT INTO table_1 SELECT * FROM table_2 WHERE col_1 = 'xxx'时间戳转换为日期12select 1571628926609 / (1000 * 60 * 60 * 24) + to_date('1970-01-01 08:00:00', 'YYYY-MM-DD HH24:MI:SS') from dualsequence 序列号create sequence SEQ_LOG_ID minvalue 1 --增长最小值 maxvalue 9999999999 --增长最大值,也可以设置NOMAXvalue -- 不设置最大值 start with 101 --从101开始计数 increment by 1 --自增步长为1 cache 50 --设置缓存cache个序列，如果系统down掉了或者其它情况将会导致序列不连续，也可以设置为---NOCACHE防止跳号 cycle; --循环,当达到最大值时,不是从start with设置的值开始循环。而是从1开始循环 CurrVal：返回 sequence的当前值 NextVal：增加sequence的值，然后返回 增加后sequence值 DROP SEQUENCE seqTest;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 日常命令]]></title>
    <url>%2F2019%2F05%2F11%2FLinux-%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819// 查找文件 findfind ~ -name fileName* // 在当前用户空间下查找文件名 fileName* 的文件// 查找文件中相关内容的行 grepgrep includeStr fileName // 查找文件 fileName 中包含 includeStr 的行// 文件内容处理 awkawk '&#123;print $1,$2&#125;' // 输出已默认空格分隔的第1列和第2列// 管道操作符 | , 上一个指令的输出作为下一个指令的输入ps -ef | grep tomcat// ex: 1. 查找 AS2_Client-BIS-PROD2.lgw 中包括 551ff040-ee58-11e9-abe3-f7b3c0a88483 的行，// 2. 并将其以制表符分隔各列，取其中的 5,11,2,3,12 列，输出各列以 | 分隔，// 3. 并将输出内容输出到 /tmp/prod2.log 中grep 551ff040-ee58-11e9-abe3-f7b3c0a88483 AS2_Client-BIS-PROD2.lgw | awk -v FS='\t' -v OFS='|' '&#123;print $5,$11,$2,$3,$12&#125;' &gt; /tmp/prod2.log// 编辑文件 sedsed 's/要被取代的字串/新的字串/g' fileName// 从头开始输出文件 headhead fileName// 从尾开始输出文件 tailtail fileNamegrep 更适合单纯的查找或匹配文本sed 更适合编辑匹配到的文本awk 更适合格式化文本，对文本进行较复杂格式处理// 直观显示文件详细内容 ls -alh // 按照由大到小排序 ls -Sl // 按照由小到大排序 ls -Slr // 列出当前目录的文件夹 ls | grep &quot;^d&quot; // 显示目录树: -a 显示所有，-d 仅显示目录，-L n 显示 n 层，-f 显示完整路径 tree -a ./ // 显示目前在Linux系统上的文件系统的磁盘使用情况统计 df -h // 列出块设备信息 lsblk // 创建文件 touch test.txt // 查看文件信息 stat test.txt // 查看文件类型 file test.txt // 复制文件夹 cp -rf srcFile desFile // 删除文件夹 rm -rf srcFile // 移动文件 mv file1 dest/file1 // 筛选文件并移动 find . -name &apos;INVENTORY_DETAILS_COMPAL_201903*&apos; -exec mv {} INVENTORY_DETAILS_COMPAL/201903/ \; // 查看系统时间 date // 前一天的日期 date -d &quot;1 day ago&quot; +&quot;%y%m%d&quot; // 前一个月的日期 date -d &quot;1 month ago&quot; +&quot;%y%m%d&quot; // 查看ip ifconfig // 修改文件目录及子目录下文件属性 rwx&lt;--&gt;421 chmod -R 755 OUT // vi 全局替换 :%s/old_str/new_str/g // vi 指定范围替换 :line1,line2s/old_str/new_str/g]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于换行]]></title>
    <url>%2F2019%2F05%2F10%2Fwrap%2F</url>
    <content type="text"><![CDATA[操作系统换行符WINDOWS OSCRLF (\r\n)UNIX OSLF (\n)MAC OSCR (\r)CR: Carriage Return, 即”\r”LF: Line Feed, 即”\n”导致的直接结果是：Windows OS 中打开 UNIX OS 下的文件时，所有文字都在一行，不会换行UNIX OS 中打开 Windows OS 下的文件时，在每行的结尾会多出一个 ^M 符号，改符号只用于显示，不会真正写入到文件中，也不会打印出来]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单]]></title>
    <url>%2F2019%2F05%2F09%2Fbook-list%2F</url>
    <content type="text"><![CDATA[《The Design of Everyday Things》 Don Norman《The Unix-Haters Handbook》 Don Norman]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mark 王垠大神的文章]]></title>
    <url>%2F2019%2F05%2F09%2Fwangyin-blogs%2F</url>
    <content type="text"><![CDATA[如何掌握所有的程序语言编程的智慧]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 Java]]></title>
    <url>%2F2019%2F05%2F08%2FJava-platform%2F</url>
    <content type="text"><![CDATA[Java 是面向对象的语言。Java 有两个最显著的特点：书写一次，到处运行。此功能得益于 JVM 的跨平台抽象，屏蔽了操作系统和硬件细节。Java 代码先由 javac 编译成 .class 字节码文件，后由 JVM 的解释器转换成机器码执行。Java 有自动的垃圾回收机制，通过垃圾回收器回收分配内存，编程人员不需要关心内存的分配和回收。JRE(Java Runtime Environment) 为 Java 的运行环境，其中包括了 JVM 和 Java 类库等。JDK(Java Development Kit) 为 Java 开发工具集，其中包括了编译器，各种诊断工具等。说 Java 是解释执行，严格来说不够准确。在 JVM 中有动态编译器，将热点代码编译成机器码，这种情况下是编译执行，而不是解释执行。知识扩展]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Errors]]></title>
    <url>%2F2019%2F05%2F08%2FSQL-Errors%2F</url>
    <content type="text"><![CDATA[遇到的 Oracle 报错总结。ORA-00001: 违反唯一约束条件ORA-00904: 标识符无效ORA-00903: 表名无效ORA-01858: 在要求输入数字处找到非数字字符ORA-01017: 用户名/口令无效; 登录被拒绝ORA-12899: 列的值太大ORA-03114：未连接数据库ORA-12541: 无监听程序ORA-01720: 不存在 xxx 的授权选项ORA-01460: 转换请求无法实施或不合理ORA-00936: 缺失表达式创建视图失败在原始 owner 授权时加上 with grant option：ex: GRANT select on edi_constant to dmt with grant option10.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统架构]]></title>
    <url>%2F2019%2F05%2F07%2FOS-architecture%2F</url>
    <content type="text"><![CDATA[最简单的计算机由 存储 + 处理器 + I/O 设备 组成，计算机的功能只是用于计算。而操作系统的作用是软件治理，协调多个程序的运行。完整架构体系服务端客户端冯·诺依曼体系三类基础零部件：中央处理器，存储，输入输出设备中央处理器只是单纯做计算的工作，具体的扩展功能通过存储和输入输出设备来实现丰富存储中的程序指令，是计算机实现复杂的运算，而通过输入输出设备增加计算机的交互汇编语言汇编语言指令基本和计算机指令一一对应，不同的是，用字符串代替指令/变量/地址，不用二进制 01 表达指令了汇编语言的程序通过汇编编译器翻译成二进制机器码汇编语言使得编程只关注软件，而不需要理解硬件，提高了编程效率操作系统有了汇编语言后，软件越来越多，但它们都需要 CPU 处理但是处理有先后优先级，都需要使用存储但是同一时间同一地址的存储只能给一个软件使用，所以出现了操作系统，用于软件的治理。软件的治理体现在以下六个方面：进程管理存储管理输入设备管理输出设备管理网络管理安全管理除了软件治理，操作系统的次要功能是提供基础的编程接口，降低软件开发难度操作系统如何获得执行权的呢？BIOS 交给它的。计算机加电后，会自动从固定地址执行 BIOS 程序，BIOS 程序中的引导程序将执行权交给操作系统的启动程序，操作系统启动后，就可以开始工作了。软件运行机制从操作系统看，计算机运行的全过程首先，执行 BIOS 程序，BIOS 程序放在主板的 ROM 中。BIOS 中的引导程序将执行权交给引导区引导程序，引导区引导程序不在 BIOS 中，而放在了外置存储中，为了保证 BIOS 不经常修改。引导区引导程序选择将执行权交给哪一个 OS 引导程序，有时候一台计算机有多个操作系统，选择好 OS 引导程序，操作系统开始启动。OS shell 程序负责和用户交互，选择要执行的程序，各个软件得以运行。如何实现可自我迭代的计算机自我迭代 ： 可以自我实现扩展，使功能越来越强大从最简单的计算机功能说起，计算机的由三部分组成：存储，处理器，输入输出设备存储：保存指令程序，输入数据，输出数据。存储可以由扩展的空间，可扩展为内置存储（CPU 可以直接读取，即寄存器/内存 RAM /主板上的 ROM）+ 外置存储。RAM 是运行内存，可读写，在断电后数据会丢失；ROM 是只读存储，断电后数据不会丢失处理器：只单纯做计算，不能扩展输入输出设备：用于计算机和外界的交互，可扩展，交互的形式由很多，比如图像，声音，文字等由此可得存储中的指令程序包括基本的以下程序：计算机主板 ROM 上的启动程序，即 BISO输入输出设备的驱动程序外置存储设备的驱动程序支持执行外置存储的引导区的机器代码的程序能跳转到外置存储的固定地址，把执行权交给该地址的引导程序支持外置存储的数据格式的程序管理外置存储的程序(ls)执行外置可执行程序的程序(sh)汇编程序编辑器 (vi)汇编编译器（asm）BIOS 中引导程序拿到执行权后，最终把执行权交给 sh 程序，sh 程序来执行外置存储上的任意程序，相当于扩展了 CPU 的指令集，是可自我迭代的体现最终的可自我迭代的计算机系统架构如下：]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沙雕日常]]></title>
    <url>%2F2019%2F05%2F07%2Ffool-life%2F</url>
    <content type="text"><![CDATA[沙雕日常，一直持续……2019.05.07我：这个冰箱一点都不热了同事：🙂我：我刚刚说了什么……]]></content>
      <tags>
        <tag>沙雕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的 HTTP 请求过程]]></title>
    <url>%2F2019%2F05%2F06%2Fbrowser-http-request%2F</url>
    <content type="text"><![CDATA[浏览器发起 HTTP 请求的相关步骤，及网络模型回顾浏览器工作流程输入 URI 时根据本地缓存的历史纪录推荐可能匹配的 URI浏览器引擎产生请求渲染引擎处理接收到的响应，负责解析及渲染内容展示到页面HTTP 请求过程浏览器从 URL 中解析得到域名根据域名查询 DNS 得到 IP与该 IP Server 完成三次握手建立 TCP 连接如果是 HTTPS，完成 TLS/SSL 握手构造 HTTP 请求，填充 HTTP 头部发送 HTTP 请求接收以 HTML 作为包体的 HTTP 响应浏览器引擎解析 HTML，渲染响应包体至页面根据 HTML 中的超链接构造其他 HTTP 请求OSI 七层网络模型应用层表示层会话层传输层网络层数据链路层物理层]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-plus 学习]]></title>
    <url>%2F2019%2F05%2F05%2FMyBatis-plus-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[使用 MyBatis-plus 主要步骤.生成 Customer extends Model对应数据库中表结构CustomerVO extends Customer对应页面展示的字段结构，比数据库中的可能多CustomerMapper extends BaseMapperCustomerMapper.xml namespace = Customer entity class写自定义的 sql生成 CustomerService extends Iservice生成 CustomerServiceImpl extends ServiceImpl&lt;CustomerMapper,Customer&gt; implement CustomerService写自定义的方法和处理逻辑]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-command]]></title>
    <url>%2F2019%2F04%2F19%2FLinux-command%2F</url>
    <content type="text"><![CDATA[学习 Linux 中，操作命令持续更新！用户操作命令功能sudo su -切换到 root 用户sudo su - [用户名]切换到指定用户权限管理命令功能chmod [权限] [文件]修改文件的权限增删改查命令功能sz [filename]下载文件rz上传文件cp [源文件名] [目标路径]复制文件rm [文件名]删除文件]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim-command]]></title>
    <url>%2F2019%2F04%2F19%2Fvim-command%2F</url>
    <content type="text"><![CDATA[windows 下的 gVim 编辑器常用命令总结，超多快捷键！模式切换Esc 到 normal；Normal 下 i 到编辑；Normal 下 : 到命令行界面风格语法功能:sy on语法高亮:sy clear取消加亮:set go=菜单工具栏隐藏:colo enving夜间模式, colo 就是设置调色方案，:colo (加一个空格)连续 tab,可选择不同的配色方案:tabnew &lt;文件地址&gt;以多页签方式打开文件:set go=e只保留编辑页面:split上下分屏:vsplit左右分屏ctrl+w H左移ctrl+w L右移ctrl+w J下移ctrl+w K上移ctrl+w c退出分屏zR打开全部zr打开当前zM折叠全部zm折叠当前快速定位语法功能gg光标移到文章头G光标移到文章尾H光标左移J光标下移K光标上移L光标右移0光标移到行首g_光标移到行尾^光标移到行首(非 blank 字符)$光标移到行尾(非 blank 字符)w下一个单词b上一个单词:&lt;行数&gt;光标移到该行首增删改查语法功能N重复某个命令 N 次v可视化y复制yy复制当前行y2/foocopy 从当前位置到 1 个 foo 之间的字符串0y$copy 本行到最后一个字符Yp向下复制行ggyG复制全文:1,3 co 5将第 1-3 行复制到 5 行:1,3 m 5将第 1-3 行移动到 第 5 行d剪切p粘贴u撤销上一次命令Ctrl+r重复上一次命令.重复上一次命令i在光标位置前开始插入a在光标位置后开始插入O在光标的上一行开始插入o在光标的下一行开始插入/搜索s替换%全文&amp;搜索到的字符:%s/a/b/gc全文替换 a 为 b，并提示:%s/a/&amp;b/gc全文在 a 的后面加上 b:%s/为../&amp;\r/gc在 为 字后面 2 个字符后换行x删除光标所在字符2x删除光标所在后的 2 个字符dd删除整行dG删除全文shift+&gt;&gt;向右 tab 一下Ctrl+q可视块q录制宏qa录制名字为 a 的宏@使用宏@a使用名字为 a 的宏6@a使用 6 次名字为 a 的宏g~~字母大小写转换gUU字母大写guu字母小写g??恢复:w保存:q退出:X设置文本打开密码键盘图参考Vim编辑器总结简明 Vim 练级攻略Linux vi/vim]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful]]></title>
    <url>%2F2019%2F04%2F10%2FRESTful%2F</url>
    <content type="text"><![CDATA[理解 RESTfulREST，Representational State Transfer，表述性状态转移资源与 URI网络中的资源需要被识别，就需要有唯一标识，URL（Uniform Resource Identifier）。URI 既可以看成是资源的地址，也可以看成资源的名称，具有自解释性URI 的设计技巧：使用 _ 或 - 来提高 URI 的可读性例如，http://www.oschina.net/news/38119/oschina-translate-reward-plan使用 / 来表示资源的层级关系例如，/orders/2012/10使用 ? 来过滤资源例如，/pulls?state=closed使用 , 或 ; 来表示同级资源关系例如，/git/git /block-sha1/sha1.h/compare/e3af72;bd63e6统一资源接口REST 在 HTTP 基础上，对同一资源，使用同一 URI，但对资源的不同操作，用标准的 HTTP 方法来实现GET安全且幂等，表示获取200（OK） - 表示已在响应中发出204（无内容） - 资源有空表示301（Moved Permanently） - 资源的URI已被更新303（See Other） - 其他（如，负载均衡）304（not modified）- 资源未更改（缓存）400 （bad request）- 指代坏请求（如，参数错误）404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务端当前无法处理请求POST不安全且不幂等，使用服务端管理的实例号创建资源，创建子资源，部分更新资源200（OK）- 如果现有资源已被更改201（created）- 如果新资源被创建202（accepted）- 已接受处理请求但尚未完成（异步处理）301（Moved Permanently）- 资源的URI被更新303（See Other）- 其他（如，负载均衡）400（bad request）- 指代坏请求404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示409 （conflict）- 通用冲突412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务当前无法处理请求PUT不安全但幂等，用客户端管理的实例号创建资源，通过替换来更新资源200 （OK）- 如果已存在资源被更改201 （created）- 如果新资源被创建301（Moved Permanently）- 资源的URI已更改303 （See Other）- 其他（如，负载均衡）400 （bad request）- 指代坏请求404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示409 （conflict）- 通用冲突412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务当前无法处理请求DELETE不安全但幂等，删除资源200 （OK）- 资源已被删除301 （Moved Permanently）- 资源的URI已更改303 （See Other）- 其他，如负载均衡400 （bad request）- 指代坏请求404 （not found）- 资源不存在409 （conflict）- 通用冲突500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务端当前无法处理请求资源的表述客户端获取的资源，准确来说，是获取的资源的表述，而不是资源本身。资源的表述，包含数据和描述数据的元数据，例如，HTTP 头 “Content-Type” 表示元数据的表现形式，可以是 html, xml, json 等对于服务器不支持的表述格式，会返回 HTTP 响应码 406（Not Acceptable）资源的链接需要页面的时候，可以在表述格式里面加入要跳转的链接来引导客户端状态的转移状态分为客户端维护的应用状态和服务端维护的资源状态客户端和服务端的交互无状态，需要在每一次请求中都包含所需的一切信息，服务端不需要在请求期间保留应用状态，只有在实际接收到请求的时候，才会关注应用状态会话状态不是作为资源状态保存在服务端，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。参考RESTful 架构详解]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EDI reference]]></title>
    <url>%2F2019%2F04%2F02%2FEDI-reference%2F</url>
    <content type="text"><![CDATA[——————-EDIFACT——————-UNA separator declaration (optional, default value = UNA:+.? ‘ )UNB Interchange header, contains sender/receiver informationUNG Functional group header (optional)UNH Message header, contains message type and versionUNT Message trailer, contains the number of segmentsUNE Functional group trailer (optional)UNZ Interchange trailer, contains the number of messageshttp://www.stylusstudio.com/edifact/D97A/messages.htm——————ANSI X12——————ISA Interchange Header SegmentGS Group Header SegmentST Transaction Set Header SegmentSE Transaction Set Trailer SegmentGE Group Trailer SegmentIEA Interchange Trailer SegmentUnlike EDIFACT, each message type has a specific number instead of a name, e.g. 810, 850, 856 etc.Further, every new release has a new version number, i.e. 4010, 4020, 4030, 5010, 6010 etc.ANSI X.12 Segments&lt;---------------- 856(DESADV) Despatch advice message ANSI X12接口名称: 850/855/860/865/856EDIFACT 接口名称：ORDERS/ORDRSP/ORDCHG/DESADV]]></content>
      <categories>
        <category>EDI</category>
      </categories>
      <tags>
        <tag>EDI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融世界观]]></title>
    <url>%2F2019%2F03%2F12%2F%E9%87%91%E8%9E%8D%E4%B8%96%E7%95%8C%E8%A7%82%2F</url>
    <content type="text"><![CDATA[金融的本质金融的三大定律金融的演化东西方货币体系的历史银行降息降准：央行的两个闸门银行的业务和分类投行发行承销：投行传统业务金融异形：投行创新业务]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何成为有效学习的高手]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B%2F</url>
    <content type="text"><![CDATA[高效学习的定义在我来看是找到最适合自己的学习手法。在相对短的时间内集中注意力，以解决一个工作和生活当中的难题为目的着手学习。你需要勤加练习，有时候还需要向名师求助找到适合你的学习方法自然主义和结构主义自然主义核心是模仿，注重文本的本身。模仿式的学习，遇到什么就学什么，积少成多，以量取胜结构主义核心是创造，侧重对结构和交互关系的一个认识，它提倡透过表面的现象去寻求底层的关系。更注重一个结构，体系化的去学习，学会之后的目的，一定是为了创造，是一种质变练习不必顾全大局避免无效学习，学习的速度和效率自然就得以提升尽可能通过更好的学习方法来把这个有效变为高效把你的目标拆碎，针对那些细节进行反复的练习，不要一开始就照顾全局碎片化学习的真相碎片化学习一定要基于搜索，搜索就是你要带着困惑和问题去执行碎片化的学习带着困惑和问题去执行碎片化的学习，最终的效果一定是要把这些碎片给连接起来必须要破除掉这种幻觉：如果你收藏完了不看的话，你不去碰它，它不是你的。不谈兴趣，用任务驱动学习成年人不需要培养兴趣，应该用任务来驱动，没有任务就自己来制造任务。生活中的任务驱动工作中的职业强迫借着有一个职业强迫带来的练习效果。在心态上要有一种自觉，自己来聘请自己，无论你在生活当中做任何事情都要这样做以教为学一方面可以是自己对自己设置的一个任务，设定的一个目标，解决了任务驱动的问题。另一方面，以教为学，其实会让你学的更好拖延症的『确诊与治疗』拖延症的表现与本质：在拖延的表现之下，本质问题其实是注意力无法集中任何人都有拖延症，有些事拖延，有些事他不拖延确认一下你拖延的那些事，被你拖延了是不是对你影响不大。如果是这样的话，其实你没有拖延 症，只要你有一些是能够按时完成的事，你就没有拖延症将任务『严峻化』你要通过做成一件事来突破，然后形成习惯就可以了设定小目标，形成惯性练习它一定伴随着一定程度的痛苦，只不过有些人他的长期目标非常明确，别人觉得他过程很苦，他自己不觉得很苦，他就能坚持下来学一些找到感觉就能掌握的一些技能，学一些技巧性比较强的东西来增强自己的信心从每天比前一天多做一个仰卧起坐开始在衣食住行上训练与专注力一个人做事和学习的专注程度会决定你做事和学习的效率平常的生活本身不能训练人的专注力，但是在平常的生活中去营造仪式感，这样会提升我们的注意力购买昂贵的学习工具如果你学习一样东西需要工具的话，你要买贵的。关于买学习工具这个事，你只要稍微让自己心疼一点，就算达到效果了便宜东西本来就不是靠专注力制造出来的，你把一样东西买来自己用，这样东西要使你感知到那种专注力，才能够对你自己的专注力形成一种训练学会一个人好好吃饭尽量吃点好的，少吃速食，少点外卖，尽量少吃自助餐每个人真的要学会自己认认真真的吃一顿火锅。最好，能学会好好做一顿饭给自己吃。这是营造仪式感非常好的行为活动使用射灯在工作和学习的环境当中尽可能去使用射灯。就是这个灯的光束能够聚集在一个比较小的范围的那种灯把自己放在舞台上应该会比坐在观众席里更专注一些进入高质量的睡眠睡眠不够，人很难做到专注直奔大师，不必从基础开始设定有效目标对于成年人来讲，要开始学一样东西已经不容易了，一定要有一个明确的目标，并且找准这个学习的切入点直奔大师直奔大师，不必从基础开始。这个大师在这里边它指代的是一种特定的一种意境，这个大师不一定是指一个人了，而是你的最终目标。如果你已经被一个大师的作品深深打动了，这个作品本身也可能就是一个很好的学习和模仿的切入点。要去到哪就从哪里开始：这里面既涵盖了兴趣，也包括了任务的驱动对于要用结构主义方法去研究的东西，还是需要踏踏实实从初级开始怯场是最糟糕的自觉。一个人他胆子变的比之前大一点，能走的路可能就会长一点给自己制造反馈要想制造反馈，你必须先有成果，就是要基于已有的成果来发现问题，所以才要制造发聩反馈的重要性当你觉得你学了一些东西之后，一定要想办法讲出来，或者应用出来，这是自己给自己制造的反馈制造文字类反馈看完一个你认为比较重要的东西，书也好，文章也好，任何文字的资料都可以，你要写一份摘要出来。写摘要的规则：summary 的写作需要对照着文本写，而不是脱稿写写 summary 要用自己的语言来写，不是选择把不要的去掉，把要的留下来。把那些文本中的重要事实，陈述和观点用自己的话写出来，绝对不能去抄人家的原话制造语音类反馈给自己录音，不断录音，不断回放制造肢体类反馈给自己录像怎样突破学习瓶颈调整方法（技术层面做出调整来突破瓶颈），调整心态解决心态问题自信心可以从打游戏这个过程当中培养起来心态调整的好，做一些事会相对比较容易扩大涉猎范围遇到瓶颈的第二个原因，可能事你的涉猎范围不够广，想要突破它你就要不断地积累更加专注，请教名师把注意力集中在一个更狭窄的范围内，以做到不去分心如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于想象，那就是盲目自信了凡走过必留下痕迹。学点什么都会有用的]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语]]></title>
    <url>%2F2019%2F03%2F04%2Fhow-to-learning%2F</url>
    <content type="text"><![CDATA[在得到里面听了许岑关于学习方法的课程，画上重点，要考！高校学习的定义在我来看是找到最适合自己的学习手法。在相对短的时间内集中注意力，以解决一个工作和生活当中的难题为目的着手学习。你需要勤加练习，有时候还需要向名师求助找到适合你的学习方法自然主义和结构主义自然主义核心是模仿，注重文本的本身。模仿式的学习，遇到什么就学什么，积少成多，以量取胜结构主义核心是创造，侧重对结构和交互关系的一个认识，它提倡透过表面的现象去寻求底层的关系。更注重一个结构，体系化的去学习，学会之后的目的，一定是为了创造，是一种质变练习不必顾全大局避免无效学习，学习的速度和效率自然就得以提升尽可能通过更好的学习方法来把这个有效变为高效把你的目标拆碎，针对那些细节进行反复的练习，不要一开始就照顾全局碎片化学习的真相碎片化学习一定要基于搜索，搜索就是你要带着困惑和问题去执行碎片化的学习带着困惑和问题去执行碎片化的学习，最终的效果一定是要把这些碎片给连接起来必须要破除掉这种幻觉：如果你收藏完了不看的话，你不去碰它，它不是你的。不谈兴趣，用任务驱动学习成年人不需要培养兴趣，应该用任务来驱动，没有任务就自己来制造任务。生活中的任务驱动，工作中的职业强迫借着有一个职业强迫带来的练习效果。在心态上要有一种自觉，自己来聘请自己，无论你在生活当中做任何事情都要这样做以教为学一方面可以是自己对自己设置的一个任务，设定的一个目标，解决了任务驱动的问题。另一方面，以教为学，其实会让你学的更好拖延症的『确诊与治疗』拖延症的表现与本质：在拖延的表现之下，本质问题其实是注意力无法集中任何人都有拖延症，有些事拖延，有些事他不拖延确认一下你拖延的那些事，被你拖延了是不是对你影响不大。如果是这样的话，其实你没有拖延症，只要你有一些是能够按时完成的事，你就没有拖延症将任务『严峻化』你要通过做成一件事来突破，然后形成习惯就可以了设定小目标，形成惯性练习它一定伴随着一定程度的痛苦，只不过有些人他的长期目标非常明确，别人觉得他过程很苦，他自己不觉得很苦，他就能坚持下来学一些找到感觉就能掌握的一些技能，学一些技巧性比较强的东西来增强自己的信心从每天比前一天多做一个仰卧起坐开始在衣食住行上训练与专注力一个人做事和学习的专注程度会决定你做事和学习的效率平常的生活本身不能训练人的专注力，但是在平常的生活中去营造仪式感，这样会提升我们的注意力购买昂贵的学习工具如果你学习一样东西需要工具的话，你要买贵的。关于买学习工具这个事，你只要稍微让自己心疼一点，就算达到效果了便宜东西本来就不是靠专注力制造出来的，你把一样东西买来自己用，这样东西要使你感知到那种专注力，才能够对你自己的专注力形成一种训练学会一个人好好吃饭尽量吃点好的，少吃速食，少点外卖，尽量少吃自助餐每个人真的要学会自己认认真真的吃一顿火锅。最好，能学会好好做一顿饭给自己吃。这是营造仪式感非常好的行为活动使用射灯在工作和学习的环境当中尽可能去使用射灯。就是这个灯的光束能够聚集在一个比较小的范围的那种灯把自己放在舞台上应该会比坐在观众席里更专注一些进入高质量的睡眠睡眠不够，人很难做到专注直奔大师，不必从基础开始设定有效目标对于成年人来讲，要开始学一样东西已经不容易了，一定要有一个明确的目标，并且找准这个学习的切入点直奔大师直奔大师，不必从基础开始。这个大师在这里边它指代的是一种特定的一种意境，这个大师不一定是指一个人了，而是你的最终目标。如果你已经被一个大师的作品深深打动了，这个作品本身也可能就是一个很好的学习和模仿的切入点。要去到哪就从哪里开始：这里面既涵盖了兴趣，也包括了任务的驱动对于要用结构主义方法去研究的东西，还是需要踏踏实实从初级开始怯场是最糟糕的自觉。一个人他胆子变的比之前大一点，能走的路可能就会长一点给自己制造反馈要想制造反馈，你必须先有成果，就是要基于已有的成果来发现问题，所以才要制造发聩反馈的重要性当你觉得你学了一些东西之后，一定要想办法讲出来，或者应用出来，这是自己给自己制造的反馈制造文字类反馈看完一个你认为比较重要的东西，书也好，文章也好，任何文字的资料都可以，你要写一份摘要出来。写摘要的规则：summary 的写作需要对照着文本写，而不是脱稿写写 summary 要用自己的语言来写，不是选择把不要的去掉，把要的留下来。把那些文本中的重要事实，陈述和观点用自己的话写出来，绝对不能去抄人家的原话制造语音类反馈给自己录音，不断录音，不断回放制造肢体类反馈给自己录像怎样突破学习瓶颈调整方法（技术层面做出调整来突破瓶颈），调整心态解决心态问题自信心可以从打游戏这个过程当中培养起来心态调整的好，做一些事会相对比较容易扩大涉猎范围遇到瓶颈的第二个原因，可能事你的涉猎范围不够广，想要突破它你就要不断地积累更加专注，请教名师把注意力集中在一个更狭窄的范围内，以做到不去分心如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于想象，那就是盲目自信了凡走过必留下痕迹。学点什么都会有用的]]></content>
      <categories>
        <category>提高</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[好看的外表让人赏心悦目~增加访客统计参考 不蒜子 ，在 [博客安装目录]\themes\hexo-theme-next\layout_partials\footer.swig 文件中添加代码12345678910111213&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;!-- 添加总访客量 --&gt;&lt;span id="busuanzi_container_site_uv"&gt; 访客数 &lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 人次&lt;/span&gt;&lt;!-- 添加'|'符号 --&gt;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&lt;!-- 添加总访问量 --&gt;&lt;span id="busuanzi_container_site_pv"&gt; 总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次&lt;/span&gt;右上角添加 fork me on github在 GitHub Ribbons 或 GitHub Corners 找到自己喜欢的样式粘贴刚才复制的代码到 themes/next/layout/_layout.swig 文件中 ( 放在 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 的下面 )，并把 href 改为自己的 github 地址页脚加闪烁红心12345678910111213// 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(192, 0, 39); //rgb可随意修改&#125;移动端样式%next%\source\css\_custom\custom.styl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// 移动端样式@media (max-width: 1023px) &#123; .container &#123; background-color: rgba(0, 0, 0, 0); &#125; .sidebar &#123; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); border-top-left-radius: 5px; border-bottom-left-radius: 5px; background-color: rgba(33, 35, 34, 0.8); &#125; .feed-link &#123; display: none !important; &#125;&#125;@media (max-width: 767px) &#123; .main &#123; padding-bottom: 120px; &#125; .main-inner &#123; margin-top: 0px; &#125; .posts-expand &#123; margin: 0px; padding-top: 0px; &#125; .posts-expand .post-title &#123; font-size: 22px; &#125; .posts-expand .post-meta &#123; font-size: 10px; &#125; .post &#123; margin-bottom: 30px !important; padding: 0px 15px 15px 15px !important; &#125; .post-body h2, h3, h4, h5, h6 &#123; margin-left: -15px; padding-left: 11px; &#125; .posts-expand .post-tags &#123; margin-top: 10px; &#125; .post-widgets &#123; margin-top: 10px; &#125; .comments &#123; margin: 40px 0px 40px 0px !important; &#125; .footer &#123; box-shadow: 0px -5px 10px 0px rgba(0, 0, 0, 0.5); &#125; .sidebar-toggle &#123; right: 20px; &#125; .back-to-top &#123; display: block; &#125; .sidebar &#123; box-shadow: 0 0 10px 0 rgba(0,0,0,.5); display: block; &#125; .code &#123; font-size: 9px; &#125;&#125;.sidebar-active #sidebar-dimmer &#123; opacity: 0;&#125;// 移动端左上角菜单按钮.site-nav-toggle &#123; position: absolute; top: 15px; left: 10px; float: left;&#125;// 移动端菜单@media (max-width: 767px) &#123; .menu &#123; text-align: center; box-shadow: 0px 5px 10px 0px rgba(0, 0, 0, 0.5); &#125; .site-nav &#123; top: initial; background-color: rgba(255, 255, 255, 0.75); border-top: none; border-bottom: none; position: relative; z-index: 1024; &#125;&#125;// 移动端顶部@media (max-width: 767px) &#123; .container .header-inner &#123; width: 100%; &#125; .header-inner &#123; padding-top: 0; padding-bottom: 0; &#125; .site-meta &#123; margin-left: 0px; float: initial; &#125; .site-title &#123; font-size: !important; letter-spacing: 0px !important; &#125; .site-subtitle&#123; letter-spacing: 0px !important; padding-bottom: 0px !important; margin-top: 2px; margin-bottom: 2px; display: inline; font-size: 11px; &#125; .menu .menu-item &#123; margin: 0px 10px !important; &#125;&#125;文章目录样式%next%\source\css\_custom\custom.styl1234567891011121314151617181920//文章目录样式.post-toc .nav .active&gt;a &#123; color: #4f7e96;&#125;.post-toc ol a:hover &#123; color: #0477ab;&#125;.post-toc .nav-item &#123; letter-spacing: 1px;&#125;.sidebar-nav .sidebar-nav-active &#123; color: #d6dee2; border-bottom-color: #649ab6;&#125;.sidebar-nav .sidebar-nav-active:hover &#123; color: #bfdae8;&#125;a &#123; border-bottom: none;&#125;侧边栏%next%\source\css\_custom\custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//侧边栏信息样式修改.site-author-name &#123; margin: 15px 0 0; color: beige; font-family: 'Comic Sans MS', sans-serif;&#125;.links-of-blogroll &#123; font-size: 14px; margin-bottom: 42px;&#125;.links-of-author &#123; margin-top: 30px; margin-bottom: 30px;&#125;.sidebar-inner &#123; color: #649ab6;&#125;.sidebar &#123; position: fixed; right: 0; top: 0; bottom: 0; width: 0; z-index: 1040; box-shadow: inset 2px 2px 40px #bdb2b2; background: #f5f5f5; background-color: rgba(33, 35, 34, 0.8);&#125;.sidebar a &#123; color: #d1e1e6; border-bottom-color: #649ab6; border-bottom: none; text-align: center;&#125;.sidebar a:hover &#123; color: #0477ab;&#125;.site-description &#123; color: beige; letter-spacing: 1px;&#125;.site-state-item &#123; display: inline-block; padding: 8px 15px; border-left: 1px solid #649ab6; color: beige;&#125;.sidebar-nav li &#123; color: #b1b199; letter-spacing: 1px;&#125;.sidebar-nav li:hover &#123; color: beige;&#125;//侧栏按钮样式.sidebar-toggle &#123; right: 10px; bottom: 43px; background: #649ab6; border-radius: 5px; box-shadow: 0 0 10px 0 rgba(0,0,0,.35);&#125;.back-to-top.back-to-top-on &#123; bottom: 10px; background: #649ab6;&#125;代码块%next%\source\css\_custom\custom.styl12345678910111213141516171819202122// 文章``代码块的自定义样式.code &#123; margin: 0px 4px; letter-spacing: 0px;&#125;// 文章```代码块顶部样式.highlight figcaption &#123; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9;&#125;.highlight figcaption a &#123; color: rgb(80, 115, 184);&#125;// 文章```代码块diff样式pre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125;参考资料Hexo-NexT搭建个人博客为NexT主题添加文章阅读量统计功能使用Hexo基于GitHub Pages搭建个人博客（三）4块钱,用Github+Hexo搭建你的个人博客：美化篇hexo的next主题个性化配置教程打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化note 标签Hexo 配置]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Github Pages + Hexo 搭建博客]]></title>
    <url>%2F2018%2F12%2F20%2F%E4%BD%BF%E7%94%A8%20Github%20Pages%20%2B%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建博客的傻白甜教程，小站第一步~环境准备安装 node.js下载 nodejs检查是否安装成功：win + R 呼出 cmd 命令窗口安装 Git下载 Git 安装包查看 Git 是否安装成功注册 Github 账号Github 官网新建 git 仓库在 Github 个人空间首页右上角点击加号仓库前面的名字为：用户名.github.io，勾选初始化时添加 README安装 Hexo安装 Hexo选定一个路径下，打开 cmd 窗口执行命令1npm install hexo-cli -g1npm install hexo --save检查 Hexo 是否安装成功1hexo -vHexo 初始化工程在 安装目录下新建一个 Hexo 的工作目录用于初始化1hexo init安装相关依赖组件1npm install生成博客1hexo g本地部署1hexo s安装远程部署组件1npm install hexo-deployer-git --saveGit 相关配置将刚刚创建的远程仓库拉到本地1git clone https://github.com/JayliLQ/JayliLQ.github.io.git用户名及邮箱配置12git config --global user.name "yourName"git config --global user.email "yourEmail"密钥配置1ssh-keygen -t rsa -C "yourEmail"将公钥 [ 以 .pub 结尾] 的文件用记事本打开，复制，粘贴到 GitHub 个人设置的 ssh Key 里面将 Git repository 和 Hexo 关联起来修改 Hexo 工作目录下的配置文件 _config.ymlrepo 值为 Git 远程仓库的地址123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/JayliLQ/JayliLQ.github.io.git branch: master部署博客到 Git 远程仓1hexo d浏览器端输入：「https://github用户名.github.io」 可直接访问博客大功告成，我可真是个小机灵鬼！😄发布新博文步骤创建 文章1hexo new post "article title"生成1hexo g部署1hexo d或者先生成再部署1hexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建 SpringBoot 项目]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%96%B0%E5%BB%BA%20SpringBoot%20%E9%A1%B9%E7%9B%AEv1.1%2F</url>
    <content type="text"><![CDATA[学习 Spring Boot 的第一步，从 hello world 开始。在 idea 里面新建 SpringBoot 项目操作步骤新建工程：File –&gt; New –&gt; Project类型选择 Spring Initializer，SDK 若没有需要点击 New 引入 JDK，Initializer Service 选择 default，点击 NextArtifact 可自定义，项目名默认和 Artifact 一致,点击 Next依赖 Web 模块，点击 Next工程在本地存放的路径可自定义，点击 Finish生成的工程目录结构和一般的 maven 项目的目录结构大致相同。相比一般的 maven 项目，SpringBoot 项目多了一些文件，主要有：一个应用入口类：src/main/java/com/example/demo1/Demo1Application.java存放静态资源的文件夹：src/main/resources/static存放模板的文件夹：src/main/resources/templates一个空的配置文件：src/main/resources/application.propertiesSpringBoot 默认会从 resource 下面的 application.properties 配置文件中读取配置信息pom.xml 中自动引入了两个依赖包spring-boot-starter-web:【web模块】spring-boot-starter-test【 测试模块】以及 maven 插件【spring-boot-maven-plugin】123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;@SpringBootApplication 注解表明 Demo1Application 为启动类@SpringBootApplication 等价于@Configuration + @EnableAutoConfiguration + @ComponentScan@Configuration 注解表明该类为配置类@EnableAutoConfiguration 注解表明能够自动配置 Spring 的上下文@ComponentScan 注解表明 Spring 会自动扫描指定路径下的所有声明 @Component 的类，并自动注册为对象1234567891011121314package com.example.demo1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@RestController@SpringBootApplicationpublic class Demo1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125;&#125;增加一个 controller mapping@RestController 表明 Demo1Application 是一个 controller，并且其中的所有方法都以 json 格式返回给前端页面@RequestMapping(“/hello”) 表明前端访问 /hello 地址的请求会映射到 controllerOne 方法来处理123456789101112131415161718192021package com.example.demo1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class Demo1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125; @RequestMapping("/hello") public String controllerOne()&#123; return "This is contollerOne!"; &#125;&#125;直接运行 main 方法，可启动项目控制台会打印出当前项目部署的端口及路径默认为 localhost:8080浏览器输入localhost:8080/hello总结SpringBoot 大量依赖注解，web 项目不再需要写 web 相关的配置文件内置了 tomcat ，启动时更简单了，不再需要配置 tomcat默认生成配置文件 application.properties，默认会从该文件读取配置下期预告创建一个 vue 项目]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>后台框架</tag>
      </tags>
  </entry>
</search>
